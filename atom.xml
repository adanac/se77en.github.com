<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AriesDevil's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://se77en.cc/"/>
  <updated>2014-07-04T09:21:51.362Z</updated>
  <id>http://se77en.cc/</id>
  
  <author>
    <name><![CDATA[Damon Zhao]]></name>
    <email><![CDATA[se77en.cc@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Go 语言中的 Array，Slice 和 Map]]></title>
    <link href="http://se77en.cc/2014/06/30/array-slice-and-map-in-golang/"/>
    <id>http://se77en.cc/2014/06/30/array-slice-and-map-in-golang/</id>
    <published>2014-06-30T00:00:00.000Z</published>
    <updated>2014-07-04T09:21:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Array(数组)">Array(数组)</h2>
<h3 id="内部机制">内部机制</h3>
<p>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p>
<p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p>
<h3 id="数组声明和初始化">数组声明和初始化</h3>
<p>通过指定数据类型和元素个数(数组长度)来声明数组。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// 声明一个长度为5的整数数组</span>
<span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span>
</pre></td></tr></table></figure>

<p>一旦数组被声明了，那么它的数据类型跟长度都不能再被改变。如果你需要更多的元素，那么只能创建一个你想要长度的新的数组，然后把原有数组的元素拷贝过去。</p>
<p>Go 语言中任何变量被声明时，都会被默认初始化为各自类型对应的 0 值，数组当然也不例外。当一个数组被声明时，它里面包含的每个元素都会被初始化为 0 值。</p>
<p>一种快速创建和初始化数组的方法是使用数组字面值。数组字面值允许我们声明我们需要的元素个数并指定数据类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 声明一个长度为5的整数数组</span>
<span class="comment">// 初始化每个元素</span>
<span class="built_in">array</span> := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">7</span>, <span class="number">77</span>, <span class="number">777</span>, <span class="number">7777</span>, <span class="number">77777</span>}
</pre></td></tr></table></figure>

<p>如果你把长度写成 <code>...</code>，Go 编译器将会根据你的元素来推导出长度：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>// 通过初始化值的个数来推导出数组容量
array := [<span class="keyword">...</span>]int{<span class="number">7</span>, <span class="number">77</span>, <span class="number">777</span>, <span class="number">7777</span>, <span class="number">77777</span>}
</pre></td></tr></table></figure>

<p>如果我们知道想要数组的长度，但是希望对指定位置元素初始化，可以这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// 声明一个长度为5的整数数组</span>
<span class="comment">// 为索引为1和2的位置指定元素初始化</span>
<span class="comment">// 剩余元素为0值</span>
<span class="built_in">array</span> := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>: <span class="number">77</span>, <span class="number">2</span>: <span class="number">777</span>}
</pre></td></tr></table></figure>

<h3 id="使用数组">使用数组</h3>
<p>使用 <code>[]</code> 操作符来访问数组元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="built_in">array</span> := [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">7</span>, <span class="number">77</span>, <span class="number">777</span>, <span class="number">7777</span>, <span class="number">77777</span>}
<span class="comment">// 改变索引为2的元素的值</span>
<span class="built_in">array</span>[<span class="number">2</span>] = <span class="number">1</span>
</pre></td></tr></table></figure>

<p>我们可以定义一个指针数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="built_in">array</span> := [<span class="number">5</span>]*<span class="keyword">int</span>{<span class="number">0</span>: <span class="keyword">new</span>(<span class="keyword">int</span>), <span class="number">1</span>: <span class="keyword">new</span>(<span class="keyword">int</span>)}

<span class="comment">// 为索引为0和1的元素赋值</span>
*<span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">7</span>
*<span class="built_in">array</span>[<span class="number">1</span>] = <span class="number">77</span>
</pre></td></tr></table></figure>

<p>在 Go 语言中数组是一个值，所以可以用它来进行赋值操作。一个数组可以被赋值给任意相同类型的数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> array1 [<span class="number">5</span>]<span class="keyword">string</span>
array2 := [<span class="number">5</span>]<span class="keyword">string</span>{<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}
array1 = array2
</pre></td></tr></table></figure>

<p>注意数组的类型同时包括数组的长度和可以被存储的元素类型，数组类型完全相同才可以互相赋值，比如下面这样就不可以：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> array1 [<span class="number">4</span>]<span class="keyword">string</span>
array2 := [<span class="number">5</span>]<span class="keyword">string</span>{<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}
array1 = array2

<span class="comment">// 编译器会报错</span>
Compiler Error:
cannot use array2 (type [<span class="number">5</span>]<span class="keyword">string</span>) <span class="keyword">as</span> type [<span class="number">4</span>]<span class="keyword">string</span> <span class="keyword">in</span> assignment
</pre></td></tr></table></figure>

<p>拷贝一个指针数组实际上是拷贝指针值，而不是指针指向的值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> array1 [<span class="number">3</span>]*<span class="keyword">string</span>
array2 := [<span class="number">3</span>]*<span class="keyword">string</span>{<span class="keyword">new</span>(<span class="keyword">string</span>), <span class="keyword">new</span>(<span class="keyword">string</span>), <span class="keyword">new</span>(<span class="keyword">string</span>)}
*array2[<span class="number">0</span>] = <span class="string">"Red"</span>
*array2[<span class="number">1</span>] = <span class="string">"Blue"</span>
*array2[<span class="number">2</span>] = <span class="string">"Green"</span>

array1 = array2
<span class="comment">// 赋值完成后，两组指针数组指向同一字符串</span>
</pre></td></tr></table></figure>

<h3 id="多维数组">多维数组</h3>
<p>数组总是一维的，但是可以组合成多维的。多维数组通常用于有父子关系的数据或者是坐标系数据：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>// 声明一个二维数组
var array [<span class="link_label">4</span>][<span class="link_reference">2</span>]int

// 使用数组字面值声明并初始化
array := [<span class="link_label">4</span>][<span class="link_reference">2</span>]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}

// 指定外部数组索引位置初始化
array := [<span class="link_label">4</span>][<span class="link_reference">2</span>]int{1: {20, 21}, 3: {40, 41}}

// 同时指定内外部数组索引位置初始化
array := [<span class="link_label">4</span>][<span class="link_reference">2</span>]int{1: {0: 20}, 3: {1: 41}}
</pre></td></tr></table></figure>

<p>同样通过 <code>[]</code> 操作符来访问数组元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>var array [<span class="link_label">2</span>][<span class="link_reference">2</span>]int

array[<span class="link_label">0</span>][<span class="link_reference">0</span>] = 0
array[<span class="link_label">0</span>][<span class="link_reference">1</span>] = 1
array[<span class="link_label">1</span>][<span class="link_reference">0</span>] = 2
array[<span class="link_label">1</span>][<span class="link_reference">1</span>] = 3
</pre></td></tr></table></figure>

<p>也同样的相同类型的多维数组可以相互赋值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>var array1 = [<span class="link_label">2</span>][<span class="link_reference">2</span>]int
var array2 = [<span class="link_label">2</span>][<span class="link_reference">2</span>]int

array[<span class="link_label">0</span>][<span class="link_reference">0</span>] = 0
array[<span class="link_label">0</span>][<span class="link_reference">1</span>] = 1
array[<span class="link_label">1</span>][<span class="link_reference">0</span>] = 2
array[<span class="link_label">1</span>][<span class="link_reference">1</span>] = 3

array1 = array2
</pre></td></tr></table></figure>

<p>因为数组是值，我们可以拷贝单独的维：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>var array3 [2]int = array1[1]
var value int = array1[<span class="link_label">1</span>][<span class="link_reference">0</span>]
</pre></td></tr></table></figure>

<h3 id="在函数中传递数组">在函数中传递数组</h3>
<p>在函数中传递数组是非常昂贵的行为，因为在函数之间传递变量永远是传递值，所以如果变量是数组，那么意味着传递整个数组，即使它很大很大很大。。。</p>
<p>举个栗子，创建一个有百万元素的整形数组，在64位的机器上它需要8兆的内存空间，来看看我们声明它和传递它时发生了什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>var array [<span class="number">1e6</span>]int
foo(array)
func foo(array [<span class="number">1e6</span>]int) {
  <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<p>每一次 <code>foo</code> 被调用，8兆内存将会被分配在栈上。一旦函数返回，会弹栈并释放内存，每次都需要8兆空间。</p>
<p>Go 语言当然不会这么傻，有更好的方法来在函数中传递数组，那就是传递指向数组的指针，这样每次只需要分配8字节内存：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>var array [<span class="number">1e6</span>]int
foo(&array)
func foo(array *[<span class="number">1e6</span>]int){
  <span class="keyword">...</span>
}
</pre></td></tr></table></figure>

<p>但是注意如果你在函数中改变指针指向的值，那么原始数组的值也会被改变。幸运的是 <code>slice</code>(切片)可以帮我们处理好这些问题，来一起看看。</p>
<h2 id="Slice(切片)">Slice(切片)</h2>
<h3 id="内部机制和基础">内部机制和基础</h3>
<p>slice 是一种可以动态数组，可以按我们的希望增长和收缩。它的增长操作很容易使用，因为有内建的 <code>append</code> 方法。我们也可以通过 <strong><em>relice</em></strong> 操作化简 slice。因为 slice 的底层内存是连续分配的，所以 slice 的索引，迭代和垃圾回收性能都很好。</p>
<p>slice 是对底层数组的抽象和控制。它包含 Go 需要对底层数组管理的三种元数据，分别是：</p>
<ol>
<li>指向底层数组的指针</li>
<li>slice 中元素的长度</li>
<li>slice 的容量(可供增长的最大值)</li>
</ol>
<h3 id="创建和初始化">创建和初始化</h3>
<p>Go 中创建 slice 有很多种方法，我们一个一个来看。</p>
<p>第一个方法是使用内建的函数 <code>make</code>。当我们使用 <code>make</code> 创建时，一个选项是可以指定 slice 的长度：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>slice := <span class="built_in">make</span>([]<span class="typename">string</span>,<span class="number"> 5</span>)
</pre></td></tr></table></figure>

<p>如果只指定了长度，那么容量默认等于长度。我们可以分别指定长度和容量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>slice := <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 3</span>,<span class="number"> 5</span>)
</pre></td></tr></table></figure>

<p>当我们分别指定了长度和容量，我们创建的 slice 就可以拥有一开始并没有访问的底层数组的容量。上面代码的 slice 中，可以访问3个元素，但是底层数组有5个元素。两个与长度不相干的元素可以被 slice 来用。新创建的 slice 同样可以共享底层数组和已存在的容量。</p>
<p>不允许创建长度大于容量的 slice：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>slice := <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 5</span>,<span class="number"> 3</span>)

Compiler Error:
<span class="built_in">len</span> larger than <span class="built_in">cap</span> in <span class="built_in">make</span>([]<span class="typename">int</span>)
</pre></td></tr></table></figure>

<p>惯用的创建 slice 的方法是使用 slice 字面量。跟创建数组很类似，不过不用指定 <code>[]</code>里的值。初始的长度和容量依赖于元素的个数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 创建一个字符串 slice</span>
<span class="comment">// 长度和容量都是 5</span>
slice := []<span class="keyword">string</span>{<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>}
</pre></td></tr></table></figure>

<p>在使用 slice 字面量创建 slice 时有一种方法可以初始化长度和容量，那就是初始化索引。下面是个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">// 创建一个字符串 slice</span>
<span class="comment">// 初始化一个有100个元素的空的字符串 slice</span>
slice := []<span class="keyword">string</span>{<span class="number">99</span>: <span class="string">""</span>}
</pre></td></tr></table></figure>

<h3 id="nil_和_empty_slice">nil 和 empty slice</h3>
<p>有的时候我们需要创建一个 nil slice，创建一个 nil slice 的方法是声明它但不初始化它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> slice []<span class="keyword">int</span>
</pre></td></tr></table></figure>

<p>创建一个 nil slice 是创建 slice 最基本的方法，很多标准库和内建函数都可以使用它。当我们想要表示一个并不存在的 slice 时它变得非常有用，比如一个返回 slice 的函数中发生异常的时候。</p>
<p>创建 empty slice 的方法就是声明并初始化一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 使用 make 创建</span>
silce := <span class="built_in">make</span>([]<span class="typename">int</span>,<span class="number"> 0</span>)

<span class="comment">// 使用 slice 字面值创建</span>
slice := []<span class="typename">int</span>{}
</pre></td></tr></table></figure>

<p>empty slice 包含0个元素并且底层数组没有分配存储空间。当我们想要表示一个空集合时它很有用处，比如一个数据库查询返回0个结果。</p>
<p>不管我们用 nil slice 还是 empty slice，内建函数 <code>append</code>，<code>len</code>和<code>cap</code>的工作方式完全相同。</p>
<h3 id="使用_slice">使用 slice</h3>
<p>为一个指定索引值的 slice 赋值跟之前数组赋值的做法完全相同。改变单个元素的值使用 <code>[]</code> 操作符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="attribute">slice :</span>=<span class="string"> []int{10, 20, 30, 40, 50}
slice[1] = 25</span>
</pre></td></tr></table></figure>

<p>我们可以在底层数组上对一部分数据进行 slice 操作，来创建一个新的 slice：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 长度为5，容量为5</span>
slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

<span class="comment">// 长度为2，容量为4</span>
newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]
</pre></td></tr></table></figure>

<p>在 slice 操作之后我们得到了两个 slice，它们共享底层数组。但是它们能访问底层数组的范围却不同，newSlice 不能访问它头指针前面的值。</p>
<p>计算任意 new slice 的长度和容量可以使用下面的公式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>对于 slice<span class="matrix">[i:j]</span> 和底层容量为 k 的数组
长度：<span class="built_in">j</span> - <span class="built_in">i</span>
容量：k - <span class="built_in">i</span>
</pre></td></tr></table></figure>

<p>必须再次明确一下现在是两个 slice 共享底层数组，因此只要有一个 slice 改变了底层数组的值，那么另一个也会随之改变：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="constant">slice</span> := []int{10, 20, 30, 40, 50}
<span class="constant">newSlice</span> := slice[1:3]
newSlice[1] = 35
</pre></td></tr></table></figure>

<p>改变 newSlice 的第二个元素的值，也会同样改变 slice 的第三个元素的值。</p>
<p>一个 slice 只能访问它长度范围内的索引，试图访问超出长度范围的索引会产生一个运行时错误。容量只可以用来增长，它只有被合并到长度才可以被访问：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>slice := []int<span class="comment">{10, 20, 30, 40, 50}</span>
newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]
newSlice[<span class="number">3</span>] = <span class="number">45</span>

Runtime Exception:
panic: runtime error: <span class="keyword">index</span> <span class="keyword">out</span> <span class="keyword">of</span> range
</pre></td></tr></table></figure>

<p>容量可以被合并到长度里，通过内建的 <code>append</code> 函数。</p>
<h3 id="slice_增长">slice 增长</h3>
<p>slice 比 数组的优势就在于它可以按照我们的需要增长，我们只需要使用 <code>append</code> 方法，然后 Go 会为我们做好一切。</p>
<p>使用 <code>append</code> 方法时我们需要一个源 slice 和需要附加到它里面的值。当 <code>append</code> 方法返回时，它返回一个新的 slice，<code>append</code> 方法总是增长 slice 的长度，另一方面，如果源 slice 的容量足够，那么底层数组不会发生改变，否则会重新分配内存空间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">// 创建一个长度和容量都为5的 slice</span>
slice := []<span class="typename">int</span><span class="number">{10</span>,<span class="number"> 20</span>,<span class="number"> 30</span>,<span class="number"> 40</span>,<span class="number"> 50</span>}

<span class="comment">// 创建一个新的 slice</span>
newSlice := slice<span class="number">[1</span><span class="number">:3</span>]

<span class="comment">// 为新的 slice append 一个值</span>
newSlice = <span class="built_in">append</span>(newSlice,<span class="number"> 60</span>)
</pre></td></tr></table></figure>

<p>因为 newSlice 有可用的容量，所以在 <code>append</code> 操作之后 slice 索引为 3 的值也变成了 60，之前说过这是因为 slice 和 newSlice 共享同样的底层数组。</p>
<p>如果没有足够可用的容量，<code>append</code> 函数会创建一个新的底层数组，拷贝已存在的值和将要被附加的新值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 创建长度和容量都为4的 slice</span>
slice := []<span class="typename">int</span><span class="number">{10</span>,<span class="number"> 20</span>,<span class="number"> 30</span>,<span class="number"> 40</span>}

<span class="comment">// 附加一个新值到 slice，因为超出了容量，所以会创建新的底层数组</span>
newSlice := <span class="built_in">append</span>(slice,<span class="number"> 50</span>)
</pre></td></tr></table></figure>

<p><code>append</code> 函数重新创建底层数组时，容量会是现有元素的两倍(前提是元素个数小于1000)，如果元素个数超过1000，那么容量会以 1.25 倍来增长。</p>
<h3 id="slice_的第三个索引参数">slice 的第三个索引参数</h3>
<p>slice 还可以有第三个索引参数来限定容量，它的目的不是为了增加容量，而是提供了对底层数组的一个保护机制，以方便我们更好的控制 <code>append</code> 操作，举个栗子：</p>
<p></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">source</span> := []<span class="keyword">string</span>{<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"plum"</span>, <span class="string">"banana"</span>, <span class="string">"grape"</span>}

<span class="comment">// 接着我们在源 slice 之上创建一个新的 slice</span>
slice := <span class="keyword">source</span>[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]
</pre></td></tr></table></figure>

<p>新创建的 slice 长度为 1，容量为 2，可以看出长度和容量的计算公式也很简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>对于 slice<span class="matrix">[i:j:k]</span>  或者 <span class="matrix">[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span>

长度： <span class="built_in">j</span> - <span class="built_in">i</span>       或者   <span class="number">3</span> - <span class="number">2</span>
容量： k - <span class="built_in">i</span>       或者   <span class="number">4</span> - <span class="number">2</span>
</pre></td></tr></table></figure>

<p>如果我们试图设置比可用容量更大的容量，会得到一个运行时错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">6</span>]


Runtime <span class="keyword">Error</span>:
panic: runtime <span class="keyword">error</span>: slice bounds out <span class="keyword">of</span> range
</pre></td></tr></table></figure>

<p>限定容量最大的用处是我们在创建新的 slice 时候限定容量与长度相同，这样以后再给新的 slice 增加元素时就会分配新的底层数组，而不会影响原有 slice 的值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">source</span> := []<span class="keyword">string</span>{<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"plum"</span>, <span class="string">"banana"</span>, <span class="string">"grape"</span>}

<span class="comment">// 接着我们在源 slice 之上创建一个新的 slice</span>
<span class="comment">// 并且设置长度和容量相同</span>
slice := <span class="keyword">source</span>[<span class="number">2</span>:<span class="number">3</span>:<span class="number">3</span>]

<span class="comment">// 添加一个新元素</span>
slice = append(slice, <span class="string">"kiwi"</span>)
</pre></td></tr></table></figure>

<p>如果没有第三个索引参数限定，添加 kiwi 这个元素时就会覆盖掉 banana。</p>
<p>内建函数 <code>append</code> 是一个变参函数，意思就是你可以一次添加多个元素，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>s1 := []<span class="keyword">int</span>{<span class="number">1</span>, <span class="number">2</span>}
s2 := []<span class="keyword">int</span>{<span class="number">3</span>, <span class="number">4</span>}

fmt.Printf(<span class="string">"<span class="variable">%v</span>\n"</span>, append(s1, s2...))

Output:
[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]
</pre></td></tr></table></figure>

<h3 id="迭代_slice">迭代 slice</h3>
<p>slice 也是一种集合，所以可以被迭代，用 <code>for</code> 配合 <code>range</code> 来迭代：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>slice := []int{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>}

for index, value := range slice {
  fmt<span class="preprocessor">.Printf</span>(<span class="string">"Index: %d  Value: %d\n"</span>, index, value)
}

<span class="label">Output:</span>
<span class="label">Index:</span> <span class="number">0</span>  Value: <span class="number">10</span>
<span class="label">Index:</span> <span class="number">1</span>  Value: <span class="number">20</span>
<span class="label">Index:</span> <span class="number">2</span>  Value: <span class="number">30</span>
<span class="label">Index:</span> <span class="number">3</span>  Value: <span class="number">40</span>
<span class="label">Index:</span> <span class="number">4</span>  Value: <span class="number">50</span>
</pre></td></tr></table></figure>

<p>当迭代时 <code>range</code> 关键字会返回两个值，第一个是索引值，第二个是索引位置值的拷贝。<strong><em>注意</em></strong>：返回的是值的拷贝而不是引用，如果我们把值的地址作为指针使用，会得到一个错误，来看看为啥：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span> ,<span class="number">40</span>}

<span class="keyword">for</span> <span class="keyword">index</span>, value := range slice {
  fmt.Printf(<span class="string">"Value: <span class="variable">%d</span>  Value-Addr: <span class="variable">%X</span>  ElemAddr: <span class="variable">%X</span>\n"</span>, value, &value, &slice[<span class="keyword">index</span>])
}

Output:
Value: <span class="number">10</span>  Value-Addr: <span class="number">10500168</span>  ElemAddr: <span class="number">1052</span>E10<span class="number">0</span>
Value: <span class="number">20</span>  Value-Addr: <span class="number">10500168</span>  ElemAddr: <span class="number">1052</span>E104
Value: <span class="number">30</span>  Value-Addr: <span class="number">10500168</span>  ElemAddr: <span class="number">1052</span>E108
Value: <span class="number">40</span>  Value-Addr: <span class="number">10500168</span>  ElemAddr: <span class="number">1052</span>E10C
</pre></td></tr></table></figure>

<p>value 变量的地址总是相同的因为它只是包含一个拷贝。如果想得到每个元素的真是地址可以使用 &amp;slice[index]。</p>
<p>如果不需要索引值，可以使用 <code>_</code> 操作符来忽略它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>slice := []int{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>}

for _, value := range slice {
  fmt<span class="preprocessor">.Printf</span>(<span class="string">"Value: %d\n"</span>, value)
}


<span class="label">Output:</span>
<span class="label">Value:</span> <span class="number">10</span>
<span class="label">Value:</span> <span class="number">20</span>
<span class="label">Value:</span> <span class="number">30</span>
<span class="label">Value:</span> <span class="number">40</span>
</pre></td></tr></table></figure>

<p><code>range</code> 总是从开始一次遍历，如果你想控制遍历的step，就用传统的 <code>for</code> 循环：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>slice := []<span class="keyword">int</span>{<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>}

<span class="keyword">for</span> <span class="keyword">index</span> := <span class="number">2</span>; <span class="keyword">index</span> &<span class="keyword">lt</span>; len(slice); <span class="keyword">index</span>++ {
  fmt.Printf(<span class="string">"Index: <span class="variable">%d</span>  Value: <span class="variable">%d</span>\n"</span>, <span class="keyword">index</span>, slice[<span class="keyword">index</span>])
}


Output:
Index: <span class="number">2</span>  Value: <span class="number">30</span>
Index: <span class="number">3</span>  Value: <span class="number">40</span>
</pre></td></tr></table></figure>

<p>同数组一样，另外两个内建函数 <code>len</code> 和 <code>cap</code> 分别返回 slice 的长度和容量。</p>
<h3 id="多维_slice">多维 slice</h3>
<p>也是同数组一样，slice 可以组合为多维的 slice：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>slice := [][]int<span class="list">{{10}</span>, <span class="list">{20, 30}</span>}
</pre></td></tr></table></figure>

<p>需要注意的是使用 <code>append</code> 方法时的行为，比如我们现在对 slice[0] 增加一个元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>slice := [][]int<span class="list">{{10}</span>, <span class="list">{20, 30}</span>}
slice[<span class="number">0</span>] = append(slice[<span class="number">0</span>], <span class="number">20</span>)
</pre></td></tr></table></figure>

<p>那么只有 slice[0] 会重新创建底层数组，slice[1] 则不会。</p>
<h3 id="在函数间传递_slice">在函数间传递 slice</h3>
<p>在函数间传递 slice 是很廉价的，因为 slice 相当于是指向底层数组的指针，让我们创建一个很大的 slice 然后传递给函数调用它：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>slice := make([]int, <span class="number">1e6</span>)

slice = foo(slice)

func foo(slice []int) []int {
    <span class="keyword">...</span>
    <span class="keyword">return</span> slice
}
</pre></td></tr></table></figure>

<p>在 64 位的机器上，slice 需要 24 字节的内存，其中指针部分需要 8 字节，长度和容量也分别需要 8 字节。</p>
<h2 id="Map">Map</h2>
<h3 id="内部机制-1">内部机制</h3>
<p>map 是一种无序的键值对的集合。map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言中的方法，接口和嵌入类型]]></title>
    <link href="http://se77en.cc/2014/05/05/methods-interfaces-and-embedded-types-in-golang/"/>
    <id>http://se77en.cc/2014/05/05/methods-interfaces-and-embedded-types-in-golang/</id>
    <published>2014-05-05T00:00:00.000Z</published>
    <updated>2014-05-06T14:32:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>在 Go 语言中，如果一个结构体和一个嵌入字段同时实现了相同的接口会发生什么呢？我们猜一下，可能有两个问题：</p>
<ul>
<li>编译器会因为我们同时有两个接口实现而报错吗？</li>
<li>如果编译器接受这样的定义，那么当接口调用时编译器要怎么确定该使用哪个实现？</li>
</ul>
<p>在写了一些测试代码并认真深入的读了一下标准之后，我发现了一些有意思的东西，而且觉得很有必要分享出来，那么让我们先从 Go 语言中的方法开始说起。</p>
<h2 id="方法">方法</h2>
<p>Go 语言中同时有函数和方法。一个方法就是一个包含了<a href="http://golang.org/ref/spec#Method_declarations" target="_blank">接受者</a>的函数，接受者可以是<a href="http://golang.org/ref/spec#Types" target="_blank">命名类型</a>或者<a href="http://golang.org/ref/spec#Struct_types" target="_blank">结构体</a>类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
<p>下面定义一个结构体类型和该类型的一个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="typedef"><span class="keyword">type</span> <span class="type">User</span> struct <span class="container">{
  <span class="type">Name</span>  <span class="title">string</span>
  <span class="type">Email</span> <span class="title">string</span>
}</span></span>

<span class="title">func</span> (u <span class="type">User</span>) <span class="type">Notify</span>() error
</pre></td></tr></table></figure>

<p>首先我们定义了一个叫做 <code>User</code> 的结构体类型，然后定义了一个该类型的方法叫做 <code>Notify</code>，该方法的接受者是一个 <code>User</code> 类型的值。要调用 <code>Notify</code> 方法我们需要一个 <code>User</code> 类型的值或者指针：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// User 类型的值可以调用接受者是值的方法</span>
damon := User{<span class="string">"AriesDevil"</span>, <span class="string">"ariesdevil@xxoo.com"</span>}
damon.Notify()

<span class="comment">// User 类型的指针同样可以调用接受者是值的方法</span>
alimon := &User{<span class="string">"A-limon"</span>, <span class="string">"alimon@ooxx.com"</span>}
alimon.Notify()
</pre></td></tr></table></figure>

<p>在这个例子中当我们使用指针时，Go <a href="http://golang.org/ref/spec#Calls" target="_blank">调整</a>和解引用指针使得调用可以被执行。<strong><em>注意</em></strong>，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作，参见：<a href="http://play.golang.org/p/DBhWU0p1Pv" target="_blank">http://play.golang.org/p/DBhWU0p1Pv</a>)。</p>
<p>我们可以修改 <code>Notify</code> 方法，让它的接受者使用指针类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">func</span> <span class="params">(u *<span class="variable">User</span>)</span> N<span class="title">otify</span><span class="params">()</span> <span class="title">error</span></span>
</pre></td></tr></table></figure>

<p>再来一次之前的调用(<strong><em>注意</em></strong>：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作，参见：<a href="http://play.golang.org/p/SYBb4xPfPh" target="_blank">http://play.golang.org/p/SYBb4xPfPh</a>)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// User 类型的值可以调用接受者是指针的方法</span>
damon := User{<span class="string">"AriesDevil"</span>, <span class="string">"ariesdevil@xxoo.com"</span>}
damon.Notify()

<span class="comment">// User 类型的指针同样可以调用接受者是指针的方法</span>
alimon := &User{<span class="string">"A-limon"</span>, <span class="string">"alimon@ooxx.com"</span>}
alimon.Notify()
</pre></td></tr></table></figure>

<p>如果你不清楚到底什么时候该使用值，什么时候该使用指针作为接受者，你可以去看一下<a href="http://se77en.cc/2014/05/04/choose-whether-to-use-a-value-or-pointer-receiver-on-methods/">这篇介绍</a>。这篇文章同时还包含了社区约定的接受者该如何命名。</p>
<h2 id="接口">接口</h2>
<p>Go 语言中的<a href="http://golang.org/doc/effective_go.html#interfaces" target="_blank">接口</a>很特别，而且提供了难以置信的一系列灵活性和抽象性。它们指定一个特定类型的值和指针表现为特定的方式。从语言角度看，接口是一种类型，它指定一个<a href="http://golang.org/ref/spec#Method_sets" target="_blank">方法集</a>，所有方法为<a href="http://golang.org/ref/spec#Interface_types" target="_blank">接口类型</a>就被认为是该接口。</p>
<p>下面定义一个接口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="typedef"><span class="keyword">type</span> <span class="type">Notifier</span> interface <span class="container">{
  <span class="type">Notify</span>() <span class="title">error</span>
}</span></span>
</pre></td></tr></table></figure>

<p>我们定义了一个叫做 <code>Notifier</code> 的接口并包含一个 <code>Notify</code> 方法。当一个接口只包含一个方法时，按照 Go 语言的<a href="http://golang.org/doc/effective_go.html#interface-names" target="_blank">约定</a>命名该接口时添加 <code>-er</code> 后缀。这个约定很有用，特别是接口和方法具有相同名字和意义的时候。</p>
<p>我们可以在接口中定义尽可能多的方法，不过在 Go 语言标准库中，你很难找到一个接口包含两个以上的方法。</p>
<h2 id="实现接口">实现接口</h2>
<p>当涉及到我们该怎么让我们的类型实现接口时，Go 语言是特别的一个。Go 语言不需要我们显式的实现类型的接口。如果一个接口里的所有方法都被我们的类型实现了，那么我们就说该类型实现了该接口。</p>
<p>让我们继续之前的例子，定义一个函数来接受任意一个实现了接口 <code>Notifier</code> 的类型的值或者指针：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>func SendNotification(notify Notifier) <span class="built_in">error</span> {
  <span class="keyword">return</span> notify.Notify()
}
</pre></td></tr></table></figure>

<p><code>SendNotification</code> 函数调用 <code>Notify</code> 方法，这个方法被传入函数的一个值或者指针实现。这样一来一个函数就可以被用来执行任意一个实现了该接口的值或者指针的指定的行为。</p>
<p>用我们的 <code>User</code> 类型来实现该接口并且传入一个 <code>User</code> 类型的值来调用 <code>SendNotification</code> 方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>func (u *User) Notify() error {
  log.Printf(<span class="string">"User: Sending User Email To %s&lt;%s&gt;\n"</span>,
      u.Name,
      u.Email)
  <span class="keyword">return</span> nil
}

func main() {
  user := User{
    Name:  <span class="string">"AriesDevil"</span>,
    Email: <span class="string">"ariesdevil@xxoo.com"</span>,
  }
  
  SendNotification(user)
}

<span class="comment">// Output:</span>
cannot <span class="keyword">use</span> user (type User) <span class="keyword">as</span> type Notifier <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> <span class="title">argument</span><span class="type">:
User</span> <span class="title">does</span> <span class="title">not</span> <span class="title">implement</span> <span class="title">Notifier</span> <span class="params">(Notify method has pointer receiver)</span></span>
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/KG8-Qb7gqM" target="_blank">http://play.golang.org/p/KG8-Qb7gqM</a></p>
<p>为什么编译器不考虑我们的值是实现该接口的类型？接口的调用规则是建立在这些方法的接受者和接口如何被调用的基础上。下面的是语言规范里定义的规则，这些规则用来说明是否我们一个类型的值或者指针<a href="http://golang.org/ref/spec#Method_sets" target="_blank">实现了</a>该接口：</p>
<ul>
<li>类型 <code>*T</code> 的可调用方法集包含接受者为 <code>*T</code> 或 <code>T</code> 的所有方法集</li>
</ul>
<p>这条规则说的是如果我们用来调用特定接口方法的接口变量是一个指针类型，那么方法的接受者可以是值类型也可以是指针类型。显然我们的例子不符合该规则，因为我们传入 <code>SendNotification</code> 函数的接口变量是一个值类型。</p>
<ul>
<li>类型 <code>T</code> 的可调用方法集包含接受者为 <code>T</code> 的所有方法</li>
</ul>
<p>这条规则说的是如果我们用来调用特定接口方法的接口变量是一个值类型，那么方法的接受者必须也是值类型该方法才可以被调用。显然我们的例子也不符合这条规则，因为我们 <code>Notify</code> 方法的接受者是一个指针类型。</p>
<p>语言规范里只有这两条规则，我通过这两条规则得出了符合我们例子的规则：</p>
<ul>
<li>类型 <code>T</code> 的可调用方法集不包含接受者为 <code>*T</code> 的方法</li>
</ul>
<p>我们碰巧赶上了我推断出的这条规则，所以编译器会报错。<code>Notify</code> 方法使用指针类型作为接受者而我们却通过值类型来调用该方法。解决办法也很简单，我们只需要传入 <code>User</code> 值的地址到 <code>SendNotification</code> 函数就好了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>func main() {
  user := &User{
    Name:  <span class="string">"AriesDevil"</span>,
    Email: <span class="string">"ariesdevil@xxoo.com"</span>,
  }
  
  SendNotification(user)
}

<span class="comment">// Output:</span>
User: Sending User Email To AriesDevil&lt;ariesdevil<span class="annotation">@xxoo</span>.com&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/kEKzyTfLjA" target="_blank">http://play.golang.org/p/kEKzyTfLjA</a></p>
<h2 id="嵌入类型">嵌入类型</h2>
<p><a href="http://golang.org/ref/spec#Struct_types" target="_blank">结构体类型</a>可以包含匿名或者嵌入字段。也叫做嵌入一个类型。当我们嵌入一个类型到结构体中时，该类型的名字充当了嵌入字段的字段名。</p>
<p>下面定义一个新的类型然后把我们的 <code>User</code> 类型嵌入进去：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="typedef"><span class="keyword">type</span> <span class="type">Admin</span> struct <span class="container">{
  <span class="type">User</span>
  <span class="type">Level</span>  <span class="title">string</span>
}</span></span>
</pre></td></tr></table></figure>

<p>我们定义了一个新类型 <code>Admin</code> 然后把 <code>User</code> 类型嵌入进去，注意这个不叫继承而叫组合。 <code>User</code> 类型跟 <code>Admin</code> 类型没有关系。</p>
<p>我们来改变一下 <code>main</code> 函数，创建一个 <code>Admin</code> 类型的变量并把变量的地址传入 <code>SendNotification</code> 函数中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>func main() {
  admin := &Admin{
    User: User{
      Name:  <span class="string">"AriesDevil"</span>,
      Email: <span class="string">"ariesdevil@xxoo.com"</span>,
    },
    Level: <span class="string">"master"</span>,
  }
  
  SendNotification(admin)
}

<span class="comment">// Output</span>
User: Sending User Email To AriesDevil&lt;ariesdevil<span class="annotation">@xxoo</span>.com&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/ivzzzk78TC" target="_blank">http://play.golang.org/p/ivzzzk78TC</a></p>
<p>事实证明，我们可以 <code>Admin</code> 类型的一个指针来调用 <code>SendNotification</code> 函数。现在 <code>Admin</code> 类型也通过来自嵌入的 <code>User</code> 类型的<strong><em>方法提升</em></strong>实现了该接口。</p>
<p>如果 <code>Admin</code> 类型包含了 <code>User</code> 类型的字段和方法，那么它们在结构体中的关系是怎么样的呢？</p>
<blockquote>
<p>当我们<a href="http://golang.org/doc/effective_go.html#embedding" target="_blank">嵌入</a>一个类型，这个类型的方法就变成了外部类型的方法，但是当它被调用时，方法的接受者是内部类型(嵌入类型)，而非外部类型。— Effective Go</p>
</blockquote>
<p>因此嵌入类型的名字充当着字段名，同时嵌入类型作为内部类型存在，我们可以使用下面的调用方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>admin<span class="preprocessor">.User</span><span class="preprocessor">.Notify</span>()

// Output
<span class="label">User:</span> Sending User Email To AriesDevil&lt;ariesdevil@xxoo<span class="preprocessor">.com</span>&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/0WL_5Q6mao" target="_blank">http://play.golang.org/p/0WL_5Q6mao</a></p>
<p>这儿我们通过类型名称来访问内部类型的字段和方法。然而，这些字段和方法也同样被提升到了外部类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>admin<span class="preprocessor">.Notify</span>()

// Output
<span class="label">User:</span> Sending User Email To AriesDevil&lt;ariesdevil@xxoo<span class="preprocessor">.com</span>&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/2snaaJojRo" target="_blank">http://play.golang.org/p/2snaaJojRo</a></p>
<p>所以通过外部类型来调用 <code>Notify</code> 方法，本质上是内部类型的方法。</p>
<p>下面是 Go 语言中内部类型<a href="http://golang.org/ref/spec#Method_sets" target="_blank">方法集提升</a>的规则：</p>
<p>给定一个结构体类型 <code>S</code> 和一个命名为 <code>T</code> 的类型，方法提升像下面规定的这样被包含在结构体方法集中：</p>
<ul>
<li>如果 <code>S</code> 包含一个匿名字段 <code>T</code>，<code>S</code> 和 <code>*S</code> 的方法集都包含接受者为 <code>T</code> 的方法提升。</li>
</ul>
<p>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为值类型的方法将被提升，可以被外部类型的值和指针调用。</p>
<ul>
<li>对于 <code>*S</code> 类型的方法集包含接受者为 <code>*T</code> 的方法提升</li>
</ul>
<p>这条规则说的是当我们嵌入一个类型，可以被外部类型的指针调用的方法集只有嵌入类型的接受者为指针类型的方法集，也就是说，当外部类型使用指针调用内部类型的方法时，只有接受者为指针类型的内部类型方法集将被提升。</p>
<ul>
<li>如果 <code>S</code> 包含一个匿名字段 <code>*T</code>，<code>S</code> 和 <code>*S</code> 的方法集都包含接受者为 <code>T</code> 或者 <code>*T</code> 的方法提升</li>
</ul>
<p>这条规则说的是当我们嵌入一个类型的指针，嵌入类型的接受者为值类型或指针类型的方法将被提升，可以被外部类型的值或者指针调用。</p>
<p>这就是语言规范里方法提升中仅有的三条规则，我根据这个推导出一条规则：</p>
<ul>
<li>如果 <code>S</code> 包含一个匿名字段 <code>T</code>，<code>S</code> 的方法集不包含接受者为 <code>*T</code> 的方法提升。</li>
</ul>
<p>这条规则说的是当我们嵌入一个类型，嵌入类型的接受者为指针的方法将不能被外部类型的值访问。这也是跟我们上面陈述的接口规则一致。</p>
<h2 id="回答开头的问题">回答开头的问题</h2>
<p>现在我们可以写程序来回答开头提出的两个问题了，首先我们让 <code>Admin</code> 类型实现 <code>Notifier</code> 接口：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>func (<span class="operator">a</span> *Admin) Notify() error {
  <span class="built_in">log</span>.Printf(<span class="string">"Admin: Sending Admin Email To %s&lt;%s&gt;\n"</span>,
      <span class="operator">a</span>.Name,
      <span class="operator">a</span>.Email)
      
  <span class="constant">return</span> nil
}
</pre></td></tr></table></figure>

<p><code>Admin</code> 类型实现的接口显示一条 admin 方面的信息。当我们使用 <code>Admin</code> 类型的指针去调用函数 <code>SendNotification</code> 时，这将帮助我们确定到底是哪个接口实现被调用了。</p>
<p>现在创建一个 <code>Admin</code> 类型的值并把它的地址传入 <code>SendNotification</code> 函数，来看看发生了什么：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>func main() {
  admin := &Admin{
    User: User{
      Name:  <span class="string">"AriesDevil"</span>,
      Email: <span class="string">"ariesdevil@xxoo.com"</span>,
    },
    Level: <span class="string">"master"</span>,
  }
  
  SendNotification(admin)
}

<span class="comment">// Output</span>
Admin: Sending Admin Email To AriesDevil&lt;ariesdevil<span class="annotation">@xxoo</span>.com&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/JGhFaJnGpS" target="_blank">http://play.golang.org/p/JGhFaJnGpS</a></p>
<p>预料之中，<code>Admin</code> 类型的接口实现被 <code>SendNotification</code> 函数调用。现在我们用外部类型来调用 <code>Notify</code> 方法会发生什么呢：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>admin<span class="preprocessor">.Notify</span>()

// Output
<span class="label">Admin:</span> Sending Admin Email To AriesDevil&lt;ariesdevil@xxoo<span class="preprocessor">.com</span>&gt;
</pre></td></tr></table></figure>

<p>详细代码：<a href="http://play.golang.org/p/EGqK6DwBOi" target="_blank">http://play.golang.org/p/EGqK6DwBOi</a></p>
<p>我们得到了 <code>Admin</code> 类型的接口实现的输出。<code>User</code> 类型的接口实现不被提升到外部类型了。</p>
<p>现在我们有了足够的依据来回答问题了：</p>
<ul>
<li>编译器会因为我们同时有两个接口实现而报错吗？</li>
</ul>
<p>不会，因为当我们使用嵌入类型时，类型名充当了字段名。嵌入类型作为结构体的内部类型包含了自己的字段和方法，且具有唯一的名字。所以我们可以有同一接口的内部实现和外部实现。</p>
<ul>
<li>如果编译器接受这样的定义，那么当接口调用时编译器要怎么确定该使用哪个实现？</li>
</ul>
<p>如果外部类型包含了符合要求的接口实现，它将会被使用。否则，通过方法提升，任何内部类型的接口实现可以直接被外部类型使用。</p>
<h2 id="总结">总结</h2>
<p>在 Go 语言中，方法，接口和嵌入类型一起工作方式是独一无二的。这些特性可以帮助我们像面向对象那样组织结构然后达到同样的目的，并且没有其它复杂的东西。用本文中谈到的语言特色，我们可以以极少的代码来构建抽象和可伸缩性的框架。</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言方法接受者类型的选择]]></title>
    <link href="http://se77en.cc/2014/05/04/choose-whether-to-use-a-value-or-pointer-receiver-on-methods/"/>
    <id>http://se77en.cc/2014/05/04/choose-whether-to-use-a-value-or-pointer-receiver-on-methods/</id>
    <published>2014-05-04T00:00:00.000Z</published>
    <updated>2014-05-06T14:35:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>很多人(特别是新手)在写 Go 语言代码时经常会问一个问题，那就是一个方法的接受者类型到底应该是值类型还是指针类型呢，Go 的 wiki 上对这点做了很好的解释，我来翻译一下。</p>
<h2 id="何时使用值类型">何时使用值类型</h2>
<ul>
<li>如果接受者是一个 <code>map</code>，<code>func</code> 或者 <code>chan</code>，使用值类型(因为它们本身就是引用类型)。</li>
<li>如果接受者是一个 <code>slice</code>，并且方法不执行 <code>reslice</code> 操作，也不重新分配内存给 <code>slice</code>，使用值类型。</li>
<li>如果接受者是一个小的数组或者原生的值类型结构体类型(比如 <code>time.Time</code> 类型)，而且没有可修改的字段和指针，又或者接受者是一个简单地基本类型像是 <code>int</code> 和 <code>string</code>，使用值类型就好了。</li>
</ul>
<p>一个值类型的接受者可以减少一定数量的垃圾生成，如果一个值被传入一个值类型接受者的方法，一个栈上的拷贝会替代在堆上分配内存(但不是保证一定成功)，所以在没搞明白代码想干什么之前，别因为这个原因而选择值类型接受者。</p>
<h2 id="何时使用指针类型">何时使用指针类型</h2>
<ul>
<li>如果方法需要修改接受者，接受者必须是指针类型。</li>
<li>如果接受者是一个包含了 <code>sync.Mutex</code> 或者类似同步字段的结构体，接受者必须是指针，这样可以避免拷贝。</li>
<li>如果接受者是一个大的结构体或者数组，那么指针类型接受者更有效率。(多大算大呢？假设把接受者的所有元素作为参数传给方法，如果你觉得参数有点多，那么它就是大)。</li>
<li>从此方法中并发的调用函数和方法时，接受者可以被修改吗？一个值类型的接受者当方法调用时会创建一份拷贝，所以外部的修改不能作用到这个接受者上。如果修改必须被原始的接受者可见，那么接受者必须是指针类型。</li>
<li>如果接受者是一个结构体，数组或者 <code>slice</code>，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接受者，这样会增加程序的可读性</li>
</ul>
<p>当你看完这个还是有疑虑，还是不知道该使用哪种接受者，那么记住使用指针接受者。</p>
<h2 id="关于接受者的命名">关于接受者的命名</h2>
<p>社区约定的接受者命名是类型的一个或两个字母的缩写(像 <code>c</code> 或者 <code>cl</code> 对于 <code>Client</code>)。不要使用泛指的名字像是 <code>me</code>，<code>this</code> 或者 <code>self</code>，也不要使用过度描述的名字，最后，如果你在一个地方使用了 <code>c</code>，那么就不要在别的地方使用 <code>cl</code>。</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言中的 new() 和 make() 的区别]]></title>
    <link href="http://se77en.cc/2014/04/25/the-difference-between-function-new-and-make-in-golang/"/>
    <id>http://se77en.cc/2014/04/25/the-difference-between-function-new-and-make-in-golang/</id>
    <published>2014-04-25T00:00:00.000Z</published>
    <updated>2014-05-06T14:36:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>Go 语言中的 <code>new</code> 和 <code>make</code> 一直是新手比较容易混淆的东西，咋一看很相似。不过解释两者之间的不同也非常容易。</p>
<h2 id="new_的主要特性">new 的主要特性</h2>
<p>首先 <code>new</code> 是内建函数，你可以从 <a href="http://golang.org/pkg/builtin/#new" target="_blank">http://golang.org/pkg/builtin/#new</a> 这儿看到它，它的定义也很简单：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>func <span class="keyword">new</span>(<span class="keyword">Type</span>) *<span class="keyword">Type</span>
</pre></td></tr></table></figure>

<p>官方文档对于它的描述是：</p>
<blockquote>
<p>内建函数 <code>new</code> 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针</p>
</blockquote>
<p>根据这段描述，我们可以自己实现一个类似 <code>new</code> 的功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">func</span> newInt() *<span class="typename">int</span> {
  <span class="keyword">var</span> i <span class="typename">int</span>
  <span class="keyword">return</span> &i
}

someInt := newInt()
</pre></td></tr></table></figure>

<p>我们这个函数的功能跟 <code>someInt := new(int)</code> 一模一样。所以在我们自己定义 new 开头的函数时，出于约定也应该返回类型的指针。</p>
<h2 id="make_的主要特性">make 的主要特性</h2>
<p><code>make</code> 也是内建函数，你可以从 <a href="http://golang.org/pkg/builtin/#make" target="_blank">http://golang.org/pkg/builtin/#make</a> 这儿看到它，它的定义比 <code>new</code> 多了一个参数，返回值也不同：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>func make(<span class="keyword">Type</span>, size IntegerType) <span class="keyword">Type</span>
</pre></td></tr></table></figure>

<p>官方文档对于它的描述是：</p>
<blockquote>
<p>内建函数 <code>make</code> 用来为 <code>slice</code>，<code>map</code> 或 <code>chan</code> 类型分配内存和初始化一个对象(<strong>注意</strong>：只能用在这三种类型上)，跟 <code>new</code> 类似，第一个参数也是一个类型而不是一个值，跟 <code>new</code> 不同的是，<code>make</code> 返回类型的引用而不是指针，而返回值也依赖于具体传入的类型，具体说明如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Slice: 第二个参数 <span class="keyword">size</span> 指定了它的长度，它的容量和长度相同。
你可以传入第三个参数来指定不同的容量值，但必须不能比长度值小。
比如 make([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)

Map: 根据 <span class="keyword">size</span> 大小来初始化分配内存，不过分配后的 map 长度为 <span class="number">0</span>，如果 <span class="keyword">size</span> 被忽略了，那么会在初始化分配内存时分配一个小尺寸的内存

Channel: 管道缓冲区依据缓冲区容量被初始化。如果容量为 <span class="number">0</span> 或者忽略容量，管道是没有缓冲区的
</pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p><code>new</code> 的作用是初始化一个指向类型的指针(<code>*T</code>)，<code>make</code> 的作用是为 <code>slice</code>，<code>map</code> 或 <code>chan</code> 初始化并返回引用(<code>T</code>)。</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于 Martini 的跨域资源共享(CORS)]]></title>
    <link href="http://se77en.cc/2014/04/09/cors-with-martini-and-golang/"/>
    <id>http://se77en.cc/2014/04/09/cors-with-martini-and-golang/</id>
    <published>2014-04-09T00:00:00.000Z</published>
    <updated>2014-05-07T15:29:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="http://www.w3.org/TR/cors/" target="_blank">CORS</a> 的全称是 Cross-Origin Resource Sharing，即：跨域资源共享</p>
<p>根据我的理解，就是马伊琍和文章结婚了，姚笛就不能和文章结了，如果还想在一起，那就得采用一定的方法，这个方法就是跨域，哦，不对，是当第三者:)</p>
<p>根据维基百科的解释，CORS 是一种机制，这个机制允许一个 Web 页面上 JavaScript 向另外的域发起 XMLHttpRequests 请求，注意不是向该 Web 页面所在域请求。这样的跨域请求，在 CORS 之前，根据同源安全策略是会被浏览器拒绝的。CORS 定义了一种方法，这个方法使浏览器和服务器相互作用来限定是否允许跨域请求。它显然比只有单纯的同源请求有用，而且还比简单的允许所有跨域访问要安全。</p>
<p>在 CORS 出现之前，已经有了很多种方法来实现跨域访问，其中最有名的就是 JSONP(JSON with Padding)，JSONP 是一种使用 JavaScript 请求其它域服务器的一种通信技术，本质就是利用同源策略的漏洞，一般来说位于 xxoo.se77en.cc 的网页是无法与非 xxoo.se77en.cc 的服务器通信的，但是 HTML 里的 <code>&lt;script&gt;</code> 元素是一个例外，利用这一例外，可以通过 JavaScript 操作浏览器页面 DOM 来动态创建 Script 对象，再将 Script 的 src 属性指向另一个域的资源，服务器就会将数据伪装成一段 JavaScript 代码来实现跨域目的。不过这种技术只能发起 GET 请求，而且安全隐患极大，因为远程服务器可以发送 JavaScript 代码，所以极易受到跨网站伪造请求(CSRF/XSRF)，所以使用 JSONP 要格外小心。</p>
<blockquote>
<p>注：目前有个正在进行的计划定义 <a href="http://json-p.org/" target="_blank">JSON-P 严格安全子集</a>，使浏览器可以对 MIME 类别是 <code>application/json-p</code> 的请求做强制处理，如果不能被解析为严格的 JSON-P，浏览器则会抛出一个错误或者忽略整个响应，目前正确的 JSONP MIME 类型仍然是 <code>application/javascript</code></p>
</blockquote>
<p>对比 JSONP 的限制，CORS 的限制主要是浏览器支持的问题(不过已经很不错了，除了万恶的 IE6)：</p>
<p><img src="/img/cors-with-martini-and-golang/cors-in-broswer.png" alt="cors-in-broswer"></p>
<h2 id="创建一个_CORS_请求">创建一个 CORS 请求</h2>
<p>完成一个 CORS 需要前后端配合。</p>
<h3 id="前端">前端</h3>
<p>对前端而言，基本没什么变化，还是使用 XMLHttpRequest 对象(IE 使用 XDomainRequest)，增加了参数和响应回调，当然如果你用 jQuery 可以不用考虑这么多了。下面用 JavaScript 和 jQuery 分别示例：</p>
<p>首先是 JavaScript，比较复杂，所以直接用大牛 Nicholas•Zakas 写的帮助方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) {

    <span class="comment">// 检查 XMLHttpRequest 对象是否包含 "withCredentials" 属性</span>
    <span class="comment">// "withCredentials" 只在 XMLHTTPRequest2 对象中存在</span>
    xhr.open(method, url, <span class="literal">true</span>);

  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>) {

    <span class="comment">// 否则，检查是否是 XDomainRequest</span>
    <span class="comment">// XDomainRequest 只在 IE 中存在, 所以用 IE 的方式来创建 CORS 请求</span>
    xhr = <span class="keyword">new</span> XDomainRequest();
    xhr.open(method, url);

  } <span class="keyword">else</span> {

    <span class="comment">// 上述都不满足，说明浏览器不支持 CORS</span>
    xhr = <span class="literal">null</span>;

  }
  <span class="keyword">return</span> xhr;
}

<span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
<span class="keyword">if</span> (!xhr) {
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CORS not supported'</span>);
}
</pre></td></tr></table></figure>

<p>如果你想要提交 cookies 需要设置 XMLHttpRequest 的 withCredentials 属性为 true：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xhr.withCredentials = <span class="literal">true</span>;
</pre></td></tr></table></figure>

<p>然后处理服务端的返回结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
 <span class="keyword">var</span> responseText = xhr.responseText;
 console.log(responseText);
 <span class="comment">// 处理返回结果</span>
};

xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  console.log(<span class="string">'There was an error!'</span>);
};
</pre></td></tr></table></figure>

<p>坑爹的是，浏览器在发生错误时的处理方式并不好，FireFox 对于所有错误返回一个为0的状态值和一个空的信息。浏览器会在 console log 里打印一个错误信息，不过这个信息却不能被 JavaScript 访问。所以处理错误时，你只知道一个错误发生了，别的一概不知。</p>
<p>前端完整代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="comment">// 创建 XHR 对象</span>
<span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) {
    <span class="comment">// XHR for Chrome/Firefox/Opera/Safari.</span>
    xhr.open(method, url, <span class="literal">true</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>) {
    <span class="comment">// XDomainRequest for IE.</span>
    xhr = <span class="keyword">new</span> XDomainRequest();
    xhr.open(method, url);
  } <span class="keyword">else</span> {
    <span class="comment">// 不支持 CORS</span>
    xhr = <span class="literal">null</span>;
  }
  <span class="keyword">return</span> xhr;
}


<span class="comment">//创建真正的一个 CORS 请求</span>
<span class="function"><span class="keyword">function</span> <span class="title">makeCorsRequest</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> url = <span class="string">'http://ooxx.se77en.cc'</span>;

  <span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
  <span class="keyword">if</span> (!xhr) {
    alert(<span class="string">'CORS not supported'</span>);
    <span class="keyword">return</span>;
  }

  <span class="comment">// 处理响应</span>
  xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> text = xhr.responseText;
    alert(<span class="string">'Response from CORS request to '</span> + url);
  };

  xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    alert(<span class="string">'Woops, there was an error making the request.'</span>);
  };

  xhr.send();
}
</pre></td></tr></table></figure>

<h3 id="服务端">服务端</h3>
<p>对服务端而言，最简单的处理方法就是增加下面一行到你的 Response Header 里：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: <span class="subst">*</span>
</pre></td></tr></table></figure>

<p>使用 go 来实现就是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>func setAllowOrigin(writer http<span class="preprocessor">.ResponseWriter</span>, r *http<span class="preprocessor">.Request</span>) {
  writer<span class="preprocessor">.Header</span>()<span class="preprocessor">.Add</span>(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>)
  return
}
</pre></td></tr></table></figure>

<p>当然，如果希望处理 POST，PUT 这类复杂的请求，或者是想要更加精确的控制 CORS，如：允许的域范围，是否允许 Cookie，允许哪些请求方法，那自然处理也会变得复杂一点。</p>
<p>对于任何非简单请求，浏览器都会先于服务器进行沟通，达成一致后，再发出实际请求。沟通的方式叫做 Preflight(起飞预备)，在发起实际请求前，浏览器首先通过 OPTIONS 方式(这样才能从服务器收到响应)。</p>
<p>Preflight 请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>OPTIONS /cors HTTP/<span class="number">1.1</span>
Origin: http:<span class="comment">//ooxx.se77en.cc</span>
Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> POST, PUT
Access-Control-Request-Headers: X-Custom-Header
</pre></td></tr></table></figure>

<ul>
<li><code>Access-Control-Request-Method</code> 是浏览器要发出的请求类型</li>
<li><code>Access-Control-Request-Headers</code> 是实际请求发送过来时额外的 Header 类型</li>
</ul>
<p>以上这些参数都是可以用逗号分隔的多值字符串。</p>
<p>Preflight 响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: http:<span class="comment">//ooxx.se77en.cc</span>
Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Methods</span>: GET, POST, PUT
Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Headers</span>: X<span class="attribute">-Custom</span><span class="attribute">-Header</span>
Content<span class="attribute">-Type</span>: text/html; charset<span class="subst">=</span>utf<span class="subst">-</span><span class="number">8</span>
</pre></td></tr></table></figure>

<ul>
<li><code>Access-Control-Allow-Origin</code> 是 CORS 响应的标配</li>
<li><code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 是服务器支持的方法和头信息，值得注意的是，这里应该填写全集，而非对应 Preflight 请求里的项目</li>
</ul>
<p>此外还有一些可选项：</p>
<ul>
<li><code>Access-Control-Max-Age</code> 是告诉浏览器多少秒以内，不再需要请求 Preflight</li>
<li><code>Access-Control-Allow-Credentials</code> 是告诉浏览器是否支持 Cookie，对应上面</li>
</ul>
<p>Preflight 沟通失败：</p>
<p>如果 Preflight 发送过来的请求权限超过了服务器所支持的，回复的方法是忽略掉 <code>Access-Control-Allow-Origin</code> 即可，就像一个普通的 HTTP 200 返回，这样浏览器就不会发起实际请求了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span>
</pre></td></tr></table></figure>

<p>沟通成功后的实际请求和响应：</p>
<p>当浏览器发起 Preflight，并确认服务器支持 CORS 无误，就可以发起实际请求步骤</p>
<p>实际请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="request">POST <span class="string">/cors</span> HTTP/1.1</span>
<span class="attribute">Origin</span>: <span class="string">http://ooxx.se77en.cc</span>
<span class="attribute">Host</span>: <span class="string">xxoo.wisteria.io</span>
<span class="attribute">X-Custom-Header</span>: <span class="string">value</span>
<span class="attribute">Accept-Language</span>: <span class="string">en-US</span>
<span class="attribute">Connection</span>: <span class="string">keep-alive</span>
<span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0...</span>
</pre></td></tr></table></figure>

<p>实际响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: http:<span class="comment">//ooxx.se77en.cc</span>
Content<span class="attribute">-Type</span>: text/html; charset<span class="subst">=</span>utf<span class="subst">-</span><span class="number">8</span>
</pre></td></tr></table></figure>

<p>交互过程：</p>
<p><img src="/img/cors-with-martini-and-golang/cors_flow.png" alt="cors_flow"></p>
<p>服务端响应流程图：</p>
<p><img src="/img/cors-with-martini-and-golang/cors_server_flowchart.png" alt="cors_server_flowchart"></p>
<h3 id="如何用_Go_语言实现？">如何用 Go 语言实现？</h3>
<p>按照上述过程，首先判断是 Preflight 还是 Actual Request：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>func (cors *Cors) ServeHTTP(w <span class="keyword">http</span>.ResponseWriter, r *<span class="keyword">http</span>.Request) {
  <span class="keyword">if</span> origin := r.Header.Get(<span class="string">"Origin"</span>); origin == <span class="string">""</span> {
      cors.corsNotValid(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> r.Method != <span class="string">"OPTIONS"</span> {
     <span class="comment"> //actual request.</span>
      cors.actualRequest(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> acrm := r.Header.Get(<span class="string">"Access-Control-Request-Method"</span>); acrm == <span class="string">""</span> {
     <span class="comment"> //actual request.</span>
      cors.actualRequest(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> {
     <span class="comment"> //preflight request.</span>
      cors.preflightRequest(w, r)
      <span class="constant">return</span>
  }
}
</pre></td></tr></table></figure>

<h3 id="在_Martini_中实现">在 Martini 中实现</h3>
<p>上面代码只是说明意图，下面我们来示范一下 CORS 在 Martini 中的应用。</p>
<p>首先是页面所在域，假设为 xxoo.wisteria.io</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.staticfile.org/jquery/1.8.2/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    $(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
        e.preventDefault();  <span class="comment">//感谢 @A-limon 提醒</span>
        <span class="keyword">var</span> btx = $(<span class="string">"#btx"</span>).val();
        <span class="keyword">var</span> url = <span class="string">"http://ooxx.se77en.cc/cors"</span>;
        $.ajax(url, {
          type:<span class="string">"POST"</span>,
          data:{<span class="string">"value"</span>:btx},
          dataType:<span class="string">"json"</span>,
          xhrFields:{
            withCredentials:<span class="literal">false</span>
          },
          success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>alert(data.msg);},
          error:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>alert(<span class="string">"errror"</span>);}
        });
      });
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>CORS<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">id</span>=<span class="value">"btx"</span> <span class="attribute">cols</span>=<span class="value">"30"</span> <span class="attribute">rows</span>=<span class="value">"10"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"btn"</span>&gt;</span>submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>接下来是服务器所在域，假设为 ooxx.se77en.cc</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>package main

import (
	<span class="string">"github.com/go-martini/martini"</span>
	<span class="string">"github.com/martini-contrib/binding"</span>
	<span class="string">"github.com/martini-contrib/cors"</span>
)

type xxoo struct {
	Value string `form:<span class="string">"value"</span>`
}

func main() {
	m := martini.Classic()
	m.Use(cors.Allow(&cors.Options{
		AllowOrigins:     []string{<span class="string">"http://xxoo.wisteria.io"</span>},
		AllowMethods:     []string{<span class="string">"POST"</span>},
		AllowHeaders:     []string{<span class="string">"Origin"</span>, <span class="string">"x-requested-with"</span>, <span class="string">"Content-Type"</span>, <span class="string">"Content-Range"</span>, <span class="string">"Content-Disposition"</span>, <span class="string">"Content-Description"</span>},
		ExposeHeaders:    []string{<span class="string">"Content-Length"</span>},
		AllowCredentials: false,
	}))

	m.Post(<span class="string">"/cors"</span>, binding.Form(xxoo{}), func(ooxx xxoo, writer http.ResponseWriter) (int, string) {
		writer.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
		log.Println(<span class="string">"******* "</span> + ooxx.Value + <span class="string">" *******"</span>)
		return http.StatusOK, `{<span class="string">"msg"</span>:<span class="string">"hello cors"</span>}`
	})
	
  m.Run()
}
</pre></td></tr></table></figure>

<p>我们使用了 Martini 的一个叫 cors 的插件，可以看到 Martini 的 cors 插件已经为我们做了很多工作，详细说明请参见 <a href="https://github.com/martini-contrib/cors#usage" target="_blank">cors 文档</a>。</p>
<h2 id="感谢">感谢</h2>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank">http://en.wikipedia.org/wiki/Cross-origin_resource_sharing</a></li>
<li><a href="http://en.wikipedia.org/wiki/JSONP" target="_blank">http://en.wikipedia.org/wiki/JSONP</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/cors/" target="_blank">http://www.html5rocks.com/en/tutorials/cors/</a></li>
<li><a href="http://semicircle.github.io/blog/2013/09/29/go-with-cors/" target="_blank">http://semicircle.github.io/blog/2013/09/29/go-with-cors/</a></li>
<li><a href="http://client.cors-api.appspot.com/client" target="_blank">http://client.cors-api.appspot.com/client</a></li>
<li><a href="http://enable-cors.org/" target="_blank">http://enable-cors.org/</a></li>
</ol>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="cors" scheme="http://se77en.cc/tags/cors/"/>
    
      <category term="martini" scheme="http://se77en.cc/tags/martini/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言的并发模型--通过通信来共享内存]]></title>
    <link href="http://se77en.cc/2014/04/08/share-by-communicating-the-concurrency-slogan-in-golang/"/>
    <id>http://se77en.cc/2014/04/08/share-by-communicating-the-concurrency-slogan-in-golang/</id>
    <published>2014-04-08T00:00:00.000Z</published>
    <updated>2014-04-09T06:27:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>我一直在找一种好的方法来解释 go 语言的<a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank">并发模型</a>：</p>
<blockquote>
<p>不要通过共享内存来通信，相反，应该通过通信来共享内存</p>
</blockquote>
<p>但是没有发现一个好的解释来满足我下面的需求：</p>
<ul>
<li>通过一个例子来说明最初的问题</li>
<li>提供一个共享内存的解决方案</li>
<li>提供一个通过通信的解决方案</li>
</ul>
<p>这篇文章我就从这三个方面来做出解释。</p>
<p>读过这篇文章后你应该会了解<strong><em>通过通信来共享内存</em></strong>的模型，以及它和<strong><em>通过共享内存来通信</em></strong>的区别，你还将看到如何分别通过这两种模型来解决访问和修改共享资源的问题。</p>
<h2 id="前提">前提</h2>
<p>设想一下我们要访问一个银行账号：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">type</span> Account <span class="keyword">interface</span> {
  Withdraw(<span class="typename">uint</span>)
  Deposit(<span class="typename">uint</span>)
  Balance() <span class="typename">int</span>
}

<span class="keyword">type</span> Bank <span class="keyword">struct</span> {
  account Account
}

<span class="keyword">func</span> NewBank(account Account) *Bank {
  <span class="keyword">return</span> &Bank{account: account}
}

<span class="keyword">func</span> (bank *Bank) Withdraw(amount <span class="typename">uint</span>, actor_name <span class="typename">string</span>) {
  fmt.Println(<span class="string">"[-]"</span>, amount, actor_name)
  bank.account.Withdraw(amount)
}

<span class="keyword">func</span> (bank *Bank) Deposit(amount <span class="typename">uint</span>, actor_name <span class="typename">string</span>) {
  fmt.Println(<span class="string">"[+]"</span>, amount, actor_name)
  bank.account.Deposit(amount)
}

<span class="keyword">func</span> (bank *Bank) Balance() <span class="typename">int</span> {
  <span class="keyword">return</span> bank.account.Balance()
}
</pre></td></tr></table></figure>

<p>因为 <code>Account</code> 是一个接口，所以我们提供一个简单的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">type</span> SimpleAccount <span class="keyword">struct</span>{
  balance <span class="typename">int</span>
}

<span class="keyword">func</span> NewSimpleAccount(balance <span class="typename">int</span>) *SimpleAccount {
  <span class="keyword">return</span> &SimpleAccount{balance: balance}
}

<span class="keyword">func</span> (acc *SimpleAccount) Deposit(amount <span class="typename">uint</span>) {
  acc.setBalance(acc.balance + <span class="typename">int</span>(amount))
}

<span class="keyword">func</span> (acc *SimpleAccount) Withdraw(amount <span class="typename">uint</span>) {
  <span class="keyword">if</span> acc.balance &gt;= <span class="typename">int</span>(mount) {
    acc.setBalance(acc.balance - <span class="typename">int</span>(amount))
  } <span class="keyword">else</span> {
    <span class="built_in">panic</span>(<span class="string">"杰克穷死"</span>)
  }
}

<span class="keyword">func</span> (acc *SimpleAccount) Balance() <span class="typename">int</span> {
  <span class="keyword">return</span> acc.balance
}

<span class="keyword">func</span> (acc *SimpleAccount) setBalance(balance <span class="typename">int</span>) {
  acc.add_some_latency()  <span class="comment">//增加一个延时函数，方便演示</span>
  acc.balance = balance
}

<span class="keyword">func</span> (acc *SimpleAccount) add_some_latency() {
  &lt;-time.After(time.Duration(rand.Intn<span class="number">(100</span>)) * time.Millisecond)
}
</pre></td></tr></table></figure>

<p>你可能注意到了 <code>balance</code> 没有被直接修改，而是被放到了  <code>setBalance</code> 方法里进行修改。这样设计是为了更好的描述问题。稍后我会做出解释。</p>
<p>把上面所有部分弄好以后我们就可以像下面这样使用它啦：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">func</span> <span class="tag">main</span>() <span class="rules">{
  <span class="rule"><span class="attribute">balance </span>:<span class="value">= <span class="number">80</span>
  b := bank.<span class="function">NewBank(bank.<span class="function">NewSimpleAccount(balance)</span>)</span>
  
  fmt.<span class="function">Println(<span class="string">"初始化余额"</span>, b.<span class="function">Balance()</span>)</span>
  
  b.<span class="function">Withdraw(<span class="number">30</span>, <span class="string">"马伊琍"</span>)</span>
  
  fmt.<span class="function">Println(<span class="string">"-----------------"</span>)</span>
  fmt.<span class="function">Println(<span class="string">"剩余余额"</span>, b.<span class="function">Balance()</span>)</span>
</span></span></span>}
</pre></td></tr></table></figure>

<p>运行上面的代码会输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
-<span class="ruby">----------------
</span>剩余余额 50
</pre></td></tr></table></figure>

<p>没错！</p>
<p>不错在现实生活中，一个银行账号可以有很多个附属卡，不同的附属卡都可以对同一个账号进行存取钱，所以我们来修改一下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">func</span> main() {
  balance :=<span class="number"> 80</span>
  b := bank.NewBank(bank.NewSimpleAccount(balance))
  
  fmt.Println(<span class="string">"初始化余额"</span>, b.Balance())
  
  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)
  
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(30</span>, <span class="string">"马伊琍"</span>); done &lt;- <span class="constant">true</span> }()
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(10</span>, <span class="string">"姚笛"</span>); done &lt;- <span class="constant">true</span> }()
  
  <span class="comment">//等待 goroutine 执行完成</span>
  &lt;-done
  &lt;-done
  
  fmt.Println(<span class="string">"-----------------"</span>)
  fmt.Println(<span class="string">"剩余余额"</span>, b.Balance())
}
</pre></td></tr></table></figure>

<p>这儿两个附属卡并发的从账号里取钱，来看看输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 70
</pre></td></tr></table></figure>

<p>这下把文章高兴坏了:)</p>
<p>结果当然是错误的，剩余余额应该是40而不是70，那么让我们看看到底哪儿出问题了。</p>
<h2 id="问题">问题</h2>
<p>当并发访问共享资源时，无效状态有很大可能会发生。</p>
<p>在我们的例子中，当两个附属卡同一时刻从同一个账号取钱后，我们最后得到银行账号(即共享资源)错误的剩余余额(即无效状态)。</p>
<p>我们来看一下执行时候的情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>                 处理情况
             --------------
             _马伊琍_|_姚笛_
 <span class="number">1.</span> 获取余额     <span class="number">80</span>  |  <span class="number">80</span>
 <span class="number">2.</span> 取钱       -<span class="number">30</span>  | -<span class="number">10</span>
 <span class="number">3.</span> 当前剩余     <span class="number">50</span>  |  <span class="number">70</span>
                <span class="keyword">...</span> | <span class="keyword">...</span>
 <span class="number">4.</span> 设置余额     <span class="number">50</span>  ?  <span class="number">70</span>  //该先设置哪个好呢？
 <span class="number">5.</span> 后设置的生效了
             --------------
 <span class="number">6.</span> 剩余余额        <span class="number">70</span>
</pre></td></tr></table></figure>

<p>上面 <code>...</code> 的地方描述了我们 <code>add_some_latency</code> 实现的延时状况，现实世界经常发生延迟情况。所以最后的剩余余额就由最后设置余额的那个附属卡决定。</p>
<h2 id="解决办法">解决办法</h2>
<p>我们通过两种方法来解决这个问题：</p>
<ul>
<li>共享内存的解决方案</li>
<li>通过通信的解决方案</li>
</ul>
<p>所有的解决方案都是简单的封装了一下 <code>SimpleAccount</code> 来实现保护机制。</p>
<h3 id="共享内存的解决方案">共享内存的解决方案</h3>
<p>又叫 “通过共享内存来通信”。</p>
<p>这种方案暗示了使用锁机制来预防同时访问和修改共享资源。锁告诉其它处理程序这个资源已经被一个处理程序占用了，因此别的处理程序需要排队直到当前处理程序处理完毕。</p>
<p>让我们来看看 <code>LockingAccount</code> 是怎么实现的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>type LockingAccount struct {
  lock    sync<span class="preprocessor">.Mutex</span>
  account *SimpleAccount
}

//封装一下 SimpleAccount
func NewLockingAccount(balance int) *LockingAccount {
  return &LockingAccount{account: NewSimpleAccount(balance)}
}

func (acc *LockingAccount) Deposit(amount uint) {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  acc<span class="preprocessor">.account</span><span class="preprocessor">.Deposit</span>(amount)
}

func (acc *LockingAccount) Withdraw(amount uint) {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  acc<span class="preprocessor">.account</span><span class="preprocessor">.Withdraw</span>(amount)
}

func (acc *LockingAccount) Balance() int {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  return acc<span class="preprocessor">.account</span><span class="preprocessor">.Balance</span>()
}
</pre></td></tr></table></figure>

<p>直接明了！注意 <code>lock sync.Lock</code>，<code>lock.Lock()</code>，<code>lock.Unlock()</code>。</p>
<p>这样每次一个附属卡访问银行账号(即共享资源)，这个附属卡会自动获得锁直到最后操作完毕。</p>
<p>我们的 <code>LockingAccount</code> 像下面这样使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">func</span> main() {
  balance :=<span class="number"> 80</span>
  b := bank.NewBank(bank.NewLockingAccount(balance))
  
  fmt.Println(<span class="string">"初始化余额"</span>, b.Balance())
  
  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)
  
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(30</span>, <span class="string">"马伊琍"</span>); done &lt;- <span class="constant">true</span> }()
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(10</span>, <span class="string">"姚笛"</span>); done &lt;- <span class="constant">true</span> }()
  
  <span class="comment">//等待 goroutine 执行完成</span>
  &lt;-done
  &lt;-done
  
  fmt.Println(<span class="string">"-----------------"</span>)
  fmt.Println(<span class="string">"剩余余额"</span>, b.Balance())
}
</pre></td></tr></table></figure>

<p>输出的结果是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 40
</pre></td></tr></table></figure>

<p>现在结果正确了！</p>
<p>在这个例子中第一个处理程序加锁后独享共享资源，其它处理程序只能等待它执行完成。</p>
<p>我们接着看一下执行时的情况，假设马伊琍先拿到了锁：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>                            处理过程
                        ________________
                        _马伊琍_|__姚笛__
        加锁                   &gt;&lt;
        得到余额            <span class="number">80</span>  |
        取钱               -<span class="number">30</span>  |
        当前余额            <span class="number">50</span>  |
                           <span class="keyword">...</span> |
        设置余额            <span class="number">50</span>  |
        解除锁                 &lt;&gt;
                               |
        当前余额                <span class="number">50</span>
                               |
        加锁                   &gt;&lt;
        得到余额                |  <span class="number">50</span>
        取钱                    | -<span class="number">10</span>
        当前余额                |  <span class="number">40</span>
                               |  <span class="keyword">...</span>
        设置余额                |  <span class="number">40</span>
        解除锁                  &lt;&gt;
                        ________________
        剩余余额                <span class="number">40</span>
</pre></td></tr></table></figure>

<p>现在我们的处理程序在访问共享资源时相继的产生了正确的结果。</p>
<h3 id="通过通信的解决方案">通过通信的解决方案</h3>
<p>又叫 “通过通信来共享内存”。</p>
<p>现在账号被命名为 <code>ConcurrentAccount</code>，像下面这样来实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="keyword">type</span> ConcurrentAccount <span class="keyword">struct</span> {
  account     *SimpleAccount
  deposits    <span class="keyword">chan</span> <span class="typename">uint</span>
  withdrawals <span class="keyword">chan</span> <span class="typename">uint</span>
  balances    <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="typename">int</span>
}

<span class="keyword">func</span> NewConcurrentAccount(amount <span class="typename">int</span>) *ConcurrentAccount{
  acc := &ConcurrentAccount{
    account :    &SimpleAccount{balance: amount},
    deposits:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">uint</span>),
    withdrawals: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">uint</span>),
    balances:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="typename">int</span>),
  }
  acc.listen()
  
  <span class="keyword">return</span> acc
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Balance() <span class="typename">int</span> {
  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)
  acc.balances &lt;- ch
  <span class="keyword">return</span> &lt;-ch
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Deposit(amount <span class="typename">uint</span>) {
  acc.deposits &lt;- amount
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Withdraw(amount <span class="typename">uint</span>) {
  acc.withdrawals &lt;- amount
}

<span class="keyword">func</span> (acc *ConcurrentAccount) listen() {
  <span class="keyword">go</span> <span class="keyword">func</span>() {
    <span class="keyword">for</span> {
      <span class="keyword">select</span> {
      <span class="keyword">case</span> amnt := &lt;-acc.deposits:
        acc.account.Deposit(amnt)
      <span class="keyword">case</span> amnt := &lt;-acc.withdrawals:
        acc.account.Withdraw(amnt)
      <span class="keyword">case</span> ch := &lt;-acc.balances:
        ch &lt;- acc.account.Balance()
      }
    }
  }()
}
</pre></td></tr></table></figure>

<p><code>ConcurrentAccount</code> 同样封装了 <code>SimpleAccount</code> ，然后增加了通信通道</p>
<p>调用代码和加锁版本的一样，这里就不写了，唯一不一样的就是初始化银行账号的时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>b := bank<span class="preprocessor">.NewBank</span>(bank<span class="preprocessor">.NewConcurrentAccount</span>(balance))
</pre></td></tr></table></figure>

<p>运行产生的结果和加锁版本一样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 40
</pre></td></tr></table></figure>

<p>让我们来深入了解一下细节。</p>
<h3 id="通过通信来共享内存是如何工作的">通过通信来共享内存是如何工作的</h3>
<p>一些基本注意点：</p>
<ul>
<li>共享资源被封装在一个控制流程中。<br>结果就是资源成为了非共享状态。没有处理程序能够直接访问或者修改资源。你可以看到访问和修改资源的方法实际上并没有执行任何改变。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  <span class="keyword">func</span> (acc *ConcurrentAccount) Balance() <span class="typename">int</span> {
    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)
    acc.balances &lt;- ch
    balance := &lt;-ch
    <span class="keyword">return</span> balance
  }
  <span class="keyword">func</span> (acc *ConcurrentAccount) Deposit(amount <span class="typename">uint</span>) {
    acc.deposits &lt;- amount
  }

  <span class="keyword">func</span> (acc *ConcurrentAccount) Withdraw(amount <span class="typename">uint</span>) {
    acc.withdrawals &lt;- amount
  }
</pre></td></tr></table></figure>


<ul>
<li>访问和修改是通过消息和控制流程通信。</li>
<li>在控制流程中任何访问和修改的动作都是相继发生的。<br>当控制流程接收到访问或者修改的请求后会立即执行相关动作。让我们仔细看看这个流程：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>  func (acc *ConcurrentAccount) listen() {
    // 执行控制流程
    go func() {
      for {
        select {
        case amnt := &lt;-acc<span class="preprocessor">.deposits</span>:
          acc<span class="preprocessor">.account</span><span class="preprocessor">.Deposit</span>(amnt)
        case amnt := &lt;-acc<span class="preprocessor">.withdrawals</span>:
          acc<span class="preprocessor">.account</span><span class="preprocessor">.Withdraw</span>(amnt)
        case ch := &lt;-acc<span class="preprocessor">.balances</span>:
          ch &lt;- acc<span class="preprocessor">.account</span><span class="preprocessor">.Balance</span>()
        }
      }
    }()
  }
</pre></td></tr></table></figure>


<p>  <a href="http://golang.org/ref/spec#Select_statements" target="_blank">select</a> 不断地从各个通道中取出消息，每个通道都跟它们所要执行的操作相一致。</p>
<p>  重要的一点是：在 <code>select</code> 声明内部的一切都是相继执行的(在同一个处理程序中排队执行)。一次只有一个事件(在通道中接受或者发送)发生，这样就保证了同步访问共享资源。</p>
<p>  领会这个有一点绕。</p>
<p>让我们用例子来看看 <code>Balance()</code> 的执行情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>         一张附属卡的流程      |   控制流程 
      <span class="comment">----------------------------------------------</span>

 <span class="number">1.</span>     b.<span class="type">Balance</span>()         |
 <span class="number">2.</span>             ch -&gt; [acc.balances]-&gt; ch
 <span class="number">3.</span>             &lt;-ch        |  balance = acc.account.<span class="type">Balance</span>()
 <span class="number">4.</span>     return  balance &lt;-[ch]&lt;- balance
 <span class="number">5</span>                          |
</pre></td></tr></table></figure>

<p>这两个流程都干了点什么呢？</p>
<h3 id="附属卡的流程">附属卡的流程</h3>
<ol>
<li>调用 <code>b.Balance()</code></li>
<li>新建通道 <code>ch</code>，将 <code>ch</code> 通道塞入通道 <code>acc.balances</code> 中与控制流程通信，这样控制流程也可以通过 <code>ch</code> 来返回余额</li>
<li>等待 <code>&lt;-ch</code> 来取得要接受的余额</li>
<li>接受余额</li>
<li>继续</li>
</ol>
<h3 id="控制流程">控制流程</h3>
<ol>
<li>空闲或者处理</li>
<li>通过 <code>acc.balances</code> 通道里面的 <code>ch</code> 通道来接受余额请求</li>
<li>取得真正的余额值</li>
<li>将余额值发送到 <code>ch</code> 通道</li>
<li>准备处理下一个请求</li>
</ol>
<p>控制流程每次只处理一个 <code>事件</code>。这也就是为什么除了描述出来的这些以外，第2-4步没有别的操作执行。</p>
<h2 id="总结">总结</h2>
<p>这篇博客描述了问题以及问题的解决办法，但那时没有深入去探究不同解决办法的优缺点。</p>
<p>下一篇中会详尽说明并且会改进解决方案。</p>
<p>请毫无顾忌的指出我的错误！</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="concurrency" scheme="http://se77en.cc/tags/concurrency/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Koa 从零打造 TODO 应用]]></title>
    <link href="http://se77en.cc/2014/02/05/koa-zero-to-todo-list-translation/"/>
    <id>http://se77en.cc/2014/02/05/koa-zero-to-todo-list-translation/</id>
    <published>2014-02-05T00:00:00.000Z</published>
    <updated>2014-02-05T09:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://blog.peterdecroos.com/blog/2014/02/01/koa-zero-to-todo-list/" target="_blank">Koa: Zero to Todo List</a></p>
<blockquote>
<h3 id="注意：你需要使用node_0-11-x外加_<code>-harmony</code>_来执行代码">注意：你需要使用node 0.11.x外加 <code>-harmony</code> 来执行代码</h3>
</blockquote>
<p>Express 团队利用新的 ECMAScript 6 的生成器语法创建了新的框架，<a href="http://koajs.com/" target="_blank">Koa</a> 框架是一个全新的 node web 框架，包含了很多有意思的东西。</p>
<h2 id="之前的方式">之前的方式</h2>
<p>在 node 标准库里，<code>http</code> 模块被用来创建服务。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> {</span>
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  <span class="comment">//这里写服务逻辑</span>
  res.end(<span class="string">''</span>);
});

server.listen(<span class="number">3000</span>, <span class="string">'127.0.0.1'</span>);
console.log(<span class="string">'listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>Express 暴露一个方法使我们可以将 <code>http.createServer</code> 作为回调。Express 中间件是一个函数集合，每个函数包含了三个参数 <code>req</code>,<code>res</code>,<code>next</code>。中间件执行一些操作，修改请求或者返回对象然后通过调用 <code>next()</code> 来传递到堆栈里的下一个中间件。它类似一个瀑布模型，在中间件栈的底部结束响应。</p>
<h2 id="进入_Koa：建立在生成器机制上的框架">进入 Koa：建立在生成器机制上的框架</h2>
<p>就像 Express，Koa 也是生成一个可以被传递到 <code>http.createServer()</code> 的回调。与 Express 不同的是，它使用生成器提供一个更加细粒度的控制流程。</p>
<p>下面是一个最基本的 Koa 应用，用来读取一个文件的内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> koa      = <span class="keyword">require</span>(<span class="string">'koa'</span>);
<span class="keyword">var</span> Promise  = <span class="keyword">require</span>(<span class="string">'bluebird'</span>);

<span class="comment">//创建 promise 版本的 fs</span>
<span class="keyword">var</span> fs = Promise.promisifyAll(<span class="keyword">require</span>(<span class="string">'fs'</span>));
<span class="comment">//创建 koa 实例</span>
<span class="keyword">var</span> app = koa();

app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">(next)</span> {</span>
  <span class="comment">//这是一个示例中间件，在控制台记录一些东西</span>
  console.log(<span class="string">'timestamp: before request =&gt; '</span>, time.now());
  <span class="keyword">yield</span> next;
  console.log(<span class="string">'timestamp: after request =&gt; '</span>, time.now());
});

app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  this.body = <span class="keyword">yield</span> fs.readFileAsync(<span class="string">'./app.js'</span>, <span class="string">'utf8'</span>);
});

app.listen(<span class="number">3000</span>);
console.log(<span class="string">'now listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>不像 Express，Koa 中中间件使用生成器来编写。在 Koa 流中下游的中间件在返回时向上流动(回形针调用方式，具体参见：koajs.cn)。通过显式的调用 <code>yield next</code> 来执行下游中间件。当下游中间件返回时，控制流回溯到上游中间件。</p>
<p>Express 通过不同的函数来传递 node 原生的 req 和 res，Koa 则是通过讲它们装入一个借口来管理上下文。不过它们仍然可以通过 <code>this</code> 关键字获取到，像这样：<code>this.req</code>, <code>this.res</code>。然而，在文档中直接使用原生对象是不被推荐的。可以预测到当在控制流中调用 <code>this.res.end(&#39;&#39;)</code> 时会抛出一个 monkey wrench(猴子扳手？此处不会翻译欢迎指正)。所以建议你使用 <code>this.request</code> 和 <code>this.response</code> 来代替直接调用原生对象。很多方法都起了别名指向直接用 <code>this</code> 调用，比如：<code>this.body</code> 就是 <code>this.response.body</code> 的别名。</p>
<p>目前似乎还没有出现可以直接得到请求体的办法。co-body 分析器可以直接的解析请求体，不过文档说别这么做，Koa 是一个年轻的框架，所以别让你的手闲下来。</p>
<h2 id="使用_Koa_做一个_TODO_应用">使用 Koa 做一个 TODO 应用</h2>
<p>刚才我们已经简单的进行了介绍，现在来试着做一个复杂点的。一个 TODO 应用貌似不错，为了简化，我们把 todos 存放在内存里。</p>
<p>Koa 是一个极简的框架，它核心里并没有提供 body 解析，session 和 routing。不幸的是 Koa 太嫩了以至于还没有很多 npm 的模块是为它来写的。浏览了一下 <a href="https://github.com/koajs/koa/wiki" target="_blank">Koa 介绍页面</a>发现有一些必要的模块可以供给我们的基本 TODO 应用来使用。</p>
<ol>
<li><a href="https://github.com/koajs/route" target="_blank">koa-route</a>: 用作路由</li>
<li><a href="https://github.com/visionmedia/co-body" target="_blank">co-body</a>: 用作解析 post 请求体</li>
<li><a href="https://github.com/koajs/static" target="_blank">koa-static</a>: 用于处理静态文件</li>
</ol>
<p>下面是基本的服务端 api</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">var</span> koa          = <span class="built_in">require</span>(<span class="string">'koa'</span>);
<span class="keyword">var</span> staticServer = <span class="built_in">require</span>(<span class="string">'koa-staitc'</span>);

<span class="comment">//这个允许我们解析原生请求对象来获取请求内容</span>
<span class="keyword">var</span> parse        = <span class="built_in">require</span>(<span class="string">'co-body'</span>);

<span class="keyword">var</span> router       = <span class="built_in">require</span>(<span class="string">'koa-route'</span>);
<span class="keyword">var</span> _            = <span class="built_in">require</span>(<span class="string">'underscore'</span>);

<span class="keyword">var</span> Promise      = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);
<span class="keyword">var</span> path         = <span class="built_in">require</span>(<span class="string">'path'</span>);

<span class="keyword">var</span> fs           = Promise.promisifyAll(<span class="built_in">require</span>(<span class="string">'fs'</span>));
<span class="keyword">var</span> app          = koa();

<span class="comment">//我们的最简单的存储方式</span>
<span class="keyword">var</span> todos = [];

<span class="comment">//获取唯一的 id 值</span>
<span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> count = <span class="number">0</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    count++;
    <span class="keyword">return</span> count;
  }
})();

<span class="comment">//处理静态资源文件夹</span>
app.use(staticServer(path.join(__dirname, <span class="string">'public'</span>)));

app.use(router.post(<span class="string">'/todos'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="comment">/*
    yield使我们可以传递异步函数，然后返回内容或者是 promises
    它会冻结当前中间件直到函数被执行完成，然后返回当前中间件继续解冻执行
  */</span>
  <span class="keyword">var</span> todo = (<span class="keyword">yield</span> parse.json(<span class="keyword">this</span>));
  
  todo.id = counter();
  todos.push(todo);
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos);
}));

app.use(router.get(<span class="string">'/todos'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos);
}));

app.use(router.delete(<span class="string">'/todos/:id'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">(id)</span> {</span>
  todos = _(todos).reject(<span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
    console.log(<span class="string">'what? '</span>, todo, id);
    <span class="keyword">return</span> todo.id === <span class="built_in">parseInt</span>(id, <span class="number">10</span>);
  }, <span class="keyword">this</span>);
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos.sort(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a - b;
  }));
}));

app.listen(<span class="number">3000</span>);
console.log(<span class="string">'listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>从 <a href="https://github.com/cultofmetatron/koa-todo" target="_blank">github</a> 上下载完整代码，github 上的版本包含了前端代码。</p>
<h3 id="一些需要注意的：">一些需要注意的：</h3>
<p><code>yield</code> 关键字可以做一些有意思的事情。如果我们向当前中间件传递一个一步函数，这个函数返回数据块或者 promise，那么它会停止执行当前中间件直到函数完成。等它返回数据块或者 promise 后，会恢复生成器执行。这样更容易阅读。</p>
<h3 id="一些警告：">一些警告：</h3>
<p><code>yield</code> 关键字使我们可以写出一些安全的代码块，但它也不总是理想的解决办法。</p>
<p>举个栗子，如果我们执行三个相互不依赖的异步操作，像下面这样…</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">var</span> a = <span class="keyword">yield</span> async1();
  <span class="keyword">var</span> b = <span class="keyword">yield</span> async2();
  <span class="keyword">var</span> c = <span class="keyword">yield</span> async3();
});
</pre></td></tr></table></figure>

<p>这会使 node 的并发失效。当我们调用 async1,我们必须等待 async1 完成才能执行 async2。不过我们可以用 promise 来优化这3个函数，然后生成一个合并的 promise。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">var</span> a = async1();
  <span class="keyword">var</span> b = async2();
  <span class="keyword">var</span> c = async3();
  <span class="keyword">var</span> result = <span class="keyword">yield</span> Promise.all([a, b, c]);
});
</pre></td></tr></table></figure>

<blockquote>
<p>注意：tjholowaychuk 大神在原文留言指出了一些问题，见下面图</p>
</blockquote>
<p>当 Koa 框架成熟时，它将会允许更加细粒度的控制以便于我们写出下一代的 web 应用。</p>
<p><img src="/img/koa-zero-to-todo-list-translation/1.png" alt="TJ"></p>
]]></content>
    
    
      <category term="javascript" scheme="http://se77en.cc/tags/javascript/"/>
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="koa" scheme="http://se77en.cc/tags/koa/"/>
    
      <category term="koa" scheme="http://se77en.cc/categories/koa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 迭代器和生成器]]></title>
    <link href="http://se77en.cc/2014/01/20/iterators-and-generators-translation/"/>
    <id>http://se77en.cc/2014/01/20/iterators-and-generators-translation/</id>
    <published>2014-01-20T00:00:00.000Z</published>
    <updated>2014-01-24T01:11:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="迭代器和生成器">迭代器和生成器</h1>
<p>翻译自 MDN 官方文档，原文地址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators?redirectlocale=en-US&amp;redirectslug=JavaScript%2FGuide%2FIterators_and_Generators" target="_blank">Iterators and Generators</a></p>
<p>处理集合里的每一项是一个非常普通的操作，JavaScript提供了许多方法来迭代一个集合，从简单的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for" target="_blank">for</a>和<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a>循环到 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map()</a>，<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter()</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">array comprehensions</a>(数组推导式)。在JavaScript 1.7中，迭代器和生成器在JavaScript核心语法中带来了新的迭代机制，而且还提供了定制 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环行为的机制。</p>
<h2 id="迭代器">迭代器</h2>
<p>迭代器是一个每次访问集合序列中一个元素的对象，并跟踪该序列中迭代的当前位置。在JavaScript中迭代器是一个对象，这个对象提供了一个 <code>next()</code> 方法，<code>next()</code> 方法返回序列中的下一个元素。当序列中所有元素都遍历完成时，该方法抛出 <code>StopIteration</code> 异常。</p>
<p>迭代器对象一旦被建立，就可以通过显式的重复调用<code>next()</code>，或者使用JavaScript的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环隐式调用。</p>
<p>简单的对对象和数组进行迭代的迭代器可以使用 <code>Iterator()</code> 被创建：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>    <span class="keyword">var</span> lang = { name: <span class="string">'JavaScript'</span>, birthYear: <span class="number">1995</span> };
    <span class="keyword">var</span> it = Iterator(lang);
</pre></td></tr></table></figure>

<p>一旦初始化完成，<code>next()</code> 方法可以被调用来依次访问对象的键值对:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"name"</span>, <span class="string">"JavaScript"</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"birthday"</span>, <span class="number">1995</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>一个 `<span class="constant">StopIteration</span>` 异常被抛出
</pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 循环可以被用来替换显式的调用 <code>next()</code> 方法。当 <code>StopIteration</code> 异常被抛出时，循环会自动终止。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次输出 it 中的一个 [key, value] 键值对</span>
</pre></td></tr></table></figure>


<p>如果你只想迭代对象的 key 值，可以往 <code>Iterator()</code> 函数中传入第二个参数，值为 <code>true</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> it)
      print(key); <span class="comment">//每次输出 key 值</span>
</pre></td></tr></table></figure>

<p>使用 <code>Iterator()</code> 访问对象的一个好处是，被添加到 <code>Object.prototype</code> 的自定义属性不会被包含在序列对象中。</p>
<p><code>Iterator()</code> 同样可以被作用在数组上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次迭代输出 [index, language] 键值对</span>
</pre></td></tr></table></figure>

<p>就像遍历对象一样，把 <code>true</code> 当做第二个参数传入遍历的结果将会是数组索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> it)
      print(i); <span class="comment">//输出 0，然后是 1，然后是 2</span>
</pre></td></tr></table></figure>

<p>使用 <code>let</code> 关键字可以在循环内部分别分配索引和值给块变量，还可以解构赋值(Destructuring Assignment)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="reserved">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="reserved">var</span> it = Iterators(langs);
    <span class="keyword">for</span> (<span class="reserved">let</span> [i, lang] <span class="keyword">in</span> it)
      <span class="built_in">print</span>(i + <span class="string">': '</span> + lang); <span class="regexp">//</span>输出 <span class="string">"0: JavaScript"</span> 等
</pre></td></tr></table></figure>

<h2 id="声明自定义迭代器">声明自定义迭代器</h2>
<p>一些代表元素集合的对象应该用一种指定的方式来迭代。</p>
<ul>
<li>迭代一个表示范围(Range)的对象应该一个接一个的返回这个范围包含的数字</li>
<li>一个树的叶子节点可以使用深度优先或者广度优先访问到</li>
<li>迭代一个代表数据库查询结果的对象应该一行一行的返回，即使整个结果集尚未全部加载到一个单一数组</li>
<li>作用在一个无限数学序列(像斐波那契序列)上的迭代器应该在不创建无限长度数据结构的前提下一个接一个的返回结果</li>
</ul>
<p>JavaScript 允许你写自定义迭代逻辑的代码，并把它作用在一个对象上</p>
<p>我们创建一个简单的 <code>Range</code> 对象，包含低和高两个值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
</pre></td></tr></table></figure>

<p>现在我们创建一个自定义迭代器，它返回一个包含范围内所有整数的序列。迭代器接口需要我们提供一个 <code>next()</code> 方法用来返回序列中的下一个元素或者是抛出 <code>StopIteration</code> 异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">RangeIterator</span><span class="params">(range)</span>{</span>
      <span class="keyword">this</span>.range = range;
      <span class="keyword">this</span>.current = <span class="keyword">this</span>.range.low;
    }
    RangeIterator.prototype.next = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.current &gt; <span class="keyword">this</span>.range.high)
        <span class="keyword">throw</span> <span class="built_in">StopIteration</span>;
      <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.current++;
    };
</pre></td></tr></table></figure>

<p>我们的 <code>RangeIterator</code> 通过 range 实例来实例化，同时维持一个 <code>current</code> 属性来跟踪当前序列的位置。</p>
<p>最后，为了让 <code>RangeIterator</code> 可以和 <code>Range</code> 结合起来，我们需要为 <code>Range</code> 添加一个特殊的 <code>__iterator__</code> 方法。当我们试图去迭代一个 <code>Range</code> 时，它将被调用，而且应该返回一个实现了迭代逻辑的 <code>RangeIterator</code> 实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(<span class="keyword">this</span>);
    };
</pre></td></tr></table></figure>

<p>完成我们的自定义迭代器后，我们就可以迭代一个范围实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">range</span> = <span class="built_in">new</span> Range<span class="number">(3</span>,<span class="number"> 5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i in <span class="keyword">range</span>)
      <span class="built_in">print</span>(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<h2 id="生成器：一种更好的方式来构建迭代器">生成器：一种更好的方式来构建迭代器</h2>
<p>虽然自定义的迭代器是一种很有用的工具，但是创建它们的时候要仔细规划，因为需要显式的维护它们的内部状态。<br>生成器提供了很强大的功能：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。</p>
<p>生成器是可以作为迭代器工厂的特殊函数。如果一个函数包含了一个或多个 <code>yield</code> 表达式，那么就称它为生成器(译者注：Node.js 还需要在函数名前加 <code>*</code> 来表示)。</p>
<blockquote>
<p>注意：只有 HTML 中被包含在 <code>&lt;script type=&quot;application/javascript;version=1.7&quot;&gt;</code> (或者更高版本)中的代码块才可以使用 <code>yield</code> 关键字。<a href="https://developer.mozilla.org/en-US/docs/XUL" target="_blank">XUL</a> (XML User Interface Language) 脚本标签不需要指定这个特殊的代码块也可以访问这些特性。</p>
</blockquote>
<p>当一个生成器函数被调用时，函数体不会即刻执行，它会返回一个 generator-iterator 对象。每次调用 generator-iterator 的 <code>next()</code> 方法，函数体就会执行到下一个 <code>yield</code> 表达式，然后返回它的结果。当函数结束或者碰到 <code>return</code> 语句，一个 <code>StopIteration</code> 异常会被抛出。</p>
<p>用一个例子来更好的说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">simpleGenerator</span><span class="params">()</span>{</span>
      <span class="keyword">yield</span> <span class="string">"first"</span>;
      <span class="keyword">yield</span> <span class="string">"second"</span>;
      <span class="keyword">yield</span> <span class="string">"third"</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)
        <span class="keyword">yield</span> i;
    }
    
    <span class="keyword">var</span> g = simpleGenerator();
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "first"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "second"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "third"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 0</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 1</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 2</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//抛出 StopIteration 异常</span>
</pre></td></tr></table></figure>

<p>生成器函数可以被一个类直接的当做 <code>__iterator__</code> 方法使用，在需要自定义迭代器的地方可以有效的减少代码量。我们使用生成器重写一下 <code>Range</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.low; i &lt;= <span class="keyword">this</span>.high; i++)
        <span class="keyword">yield</span> i;
    };
    <span class="keyword">var</span> range = <span class="keyword">new</span> Range(<span class="number">3</span>, <span class="number">5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> range)
      print(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<p>不是所有的生成器都会终止，你可以创建一个代表无限序列的生成器。下面的生成器实现一个斐波那契序列，就是每一个元素都是前面两个的和：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">yield</span> current;
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 2</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 3</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 5</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 8</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 13</span>
</pre></td></tr></table></figure>

<p>生成器函数可以带有参数，并且会在第一次调用函数时使用这些参数。生成器可以被终止(引起它抛出 <code>StopIteration</code> 异常)通过使用 <code>return</code> 语句。下面的 <code>fibonacci()</code> 变体带有一个可选的 limit 参数，当条件被触发时终止函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(limit)</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span>(<span class="number">1</span>){
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">if</span> (limit && current &gt; limit)
          <span class="keyword">return</span>;
        <span class="keyword">yield</span> current;
      }
    }
</pre></td></tr></table></figure>

<h2 id="生成器高级特性">生成器高级特性</h2>
<p>生成器可以根据需求计算yield返回值，这使得它可以表示以前昂贵的序列计算需求，甚至是上面所示的无限序列。</p>
<p>除了 <code>next()</code> 方法，generator-iterator 对象还有一个 <code>send()</code> 方法，该方法可以修改生成器的内部状态。传给 <code>send()</code> 的值将会被当做最后一个 <code>yield</code> 表达式的结果，并且会暂停生成器。在你使用 <code>send()</code> 方法传一个指定值前，你必须至少调用一次 <code>next()</code> 来启动生成器。</p>
<p>下面的斐波那契生成器使用 <code>send()</code> 方法来重启序列：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">var</span> reset = <span class="keyword">yield</span> current;
        <span class="keyword">if</span> (reset) {
          fn1 = <span class="number">1</span>;
          fn2 = <span class="number">1</span>;
        }
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//5</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//8</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//13</span>
    <span class="keyword">print</span>(sequence.send(<span class="keyword">true</span>)); <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
</pre></td></tr></table></figure>

<blockquote>
<p>注意：有意思的一点是，调用 <code>send(undefined)</code> 和调用 <code>next()</code> 是完全同等的。不过，当调用 <code>send()</code> 方法启动一个新的生成器时，除了 <code>undefined</code> 其它的值都会抛出一个 <code>TypeError</code> 异常。</p>
</blockquote>
<p>你可以调用 <code>throw</code> 方法并且传递一个它应该抛出的异常值来强制生成器抛出一个异常。此异常将从当前上下文抛出并暂停生成器，类似当前的 <code>yield</code> 执行，只不过换成了 <code>throw value</code> 语句。</p>
<p>如果在抛出异常的处理过程中没有遇到 <code>yield</code> ，该异常将会被传递直到调用 <code>throw()</code> 方法，并且随后调用 <code>next()</code> 将会导致 <code>StopIteration</code> 异常被抛出。</p>
<p>生成器拥有一个 <code>close()</code> 方法来强制生成器结束。结束一个生成器会产生如下影响：</p>
<ol>
<li>所有生成器中有效的 <code>finally</code> 字句将会执行</li>
<li>如果 <code>finally</code> 字句抛出了除 <code>StopIteration</code> 以外的任何异常，该异常将会被传递到 <code>close()</code> 方法的调用者</li>
<li>生成器会终止</li>
</ol>
<h2 id="生成器表达式">生成器表达式</h2>
<p><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">数组推导式</a>的一个明显缺点是，它们会导致整个数组在内存中构造。当输入到推导式的本身是个小数组时它的开销是微不足道的—但是，当输入数组很大或者创建一个新的昂贵(或者是无限的)数组生成器时就可能出现问题。</p>
<p>生成器允许对序列延迟计算(lazy computation)，在需要时按需计算元素。生成器表达式在句法上几乎和数组推导式相同—它用圆括号来代替方括号(而且用 <code>for...in</code> 代替 <code>for each...in</code>)—但是它创建一个生成器而不是数组，这样就可以延迟计算。你可以把它想象成创建生成器的简短语法。</p>
<p>假设我们有一个迭代器 <code>it</code> 来迭代一个巨大的整数序列。我们需要创建一个新的迭代器来迭代偶数。一个数组推导式将会在内存中创建整个包含所有偶数的数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> doubles = [i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it)];
</pre></td></tr></table></figure>

<p>而生成器表达式将会创建一个新的迭代器，并且在需要的时候按需来计算偶数值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var it2 = (i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//it</span> 里面的第一个偶数
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//it</span> 里面的第二个偶数
</pre></td></tr></table></figure>

<p>当一个生成器被用做函数的参数，圆括号被用做函数调用，意味着最外层的圆括号可以被省略：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">result</span> = doSomething(i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
</pre></td></tr></table></figure>

<hr>
<p><a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a> 主题已华丽更新，再次推荐！</p>
]]></content>
    
    
      <category term="javascript" scheme="http://se77en.cc/tags/javascript/"/>
    
      <category term="iterator" scheme="http://se77en.cc/tags/iterator/"/>
    
      <category term="generator" scheme="http://se77en.cc/tags/generator/"/>
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="javascript" scheme="http://se77en.cc/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[告别node-forever,拥抱PM2]]></title>
    <link href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/"/>
    <id>http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/</id>
    <published>2013-06-27T06:43:36.000Z</published>
    <updated>2014-02-05T09:34:08.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址:<a href="http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Goodbye node-forever,hello PM2</a></p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm22.png" alt="pm2-logo"></p>
<p>devo.ps团队对JavaScript的迷恋已经不是什么秘密了;node.js作为服务器端,AngularJS作为客户端,某种程度上说,我们的堆栈是用它建成的.我们构建<a href="http://devo.ps/blog/2013/01/31/farewell-to-regular-web-development-approaches.html" target="_blank">静态客户端和RESTful JSON API</a>的方法意味着我们跑了很多的node.js,我必须承认尽管node.js的一切都令人敬畏,但当我们在生产环境中运行它时它仍然会让我们感到头疼.相比一些更加成熟的语言,它的工具和最佳实践仍然缺乏(试想一下:监控,日志,错误处理).</p>
<p>到目前为止,我们仍然依赖漂亮俏皮的<a href="https://github.com/nodejitsu/forever" target="_blank">node-forever模块</a>.它是非常伟大的模块,不过依然缺失一些功能:</p>
<ul>
<li>有限的监控和日志功能</li>
<li>进程管理配置的支持差</li>
<li>不支持集群</li>
<li>代码库老化(意味着在升级node.js时频繁的失败)</li>
</ul>
<p>这就是为什么我们要在过去的几个月里去写<a href="https://github.com/Unitech/pm2" target="_blank">PM2模块</a>.在我们即将发布针对生产环境的正式版之前我们想先让您看一眼.</p>
<h3 id="<strong>PM2到底是什么个东西呢?</strong>"><strong>PM2到底是什么个东西呢?</strong></h3>
<p>首先第一件事,你需要先通过<code>npm</code>来安装它:</p>
<pre><code>npm <span class="keyword">install</span> -g pm2
</code></pre><p>让我们通过表格来对比下:</p>
<table class="table table-bordered table-striped table-condensed"><br>   <tr><br>      <th width="50%">Feature</th><br>      <th width="25%">Forever</th><br>      <th width="25%">PM2</th><br>   </tr><br>   <tr><br>      <td>Keep Alive</td><br>      <td>&#10004;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Coffeescript</td><br>      <td>&#10004;</td><br>      <td>&nbsp;</td><br>   </tr><br>   <tr><br>      <td>Log aggregation</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>API</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Terminal monitoring</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Clustering</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>JSON configuration</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br></table>


<p>现在让我来介绍一点点主要特性…</p>
<h3 id="<strong>原生的集群化支持</strong>"><strong>原生的集群化支持</strong></h3>
<p>Node v0.6引入了集群特性,允许你在多个Node应用中共享socket.问题在于,它不能在容器外运行而且需要一些额外的配置来处理主进程和子进程.</p>
<p>PM2原生支持处理这个问题,而且不需要额外的代码:PM2本身作为主进程,然后它将你的代码封装到一个特殊的集群进程里,就像node.js一样,为你的代码文件添加一些全局变量.</p>
<p>想要启动一个使用所有CPU核心的集群,你只需要键入如下的指令:</p>
<pre><code>$ pm2 <span class="operator"><span class="keyword">start</span> app.js -i <span class="aggregate">max</span></span>
</code></pre><p>然后:</p>
<pre><code><span class="variable">$ </span>pm2 list
</code></pre><p>然后就会显示类似下面的东西(ASCII UI FTW);</p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-list.png" alt="pm2-list"></p>
<p>就像你看到的,现在你的应用有多少个进程就取决于你的CPU核心数了</p>
<h3 id="<strong>按照termcaps-HTOP(Linux下的系统监控与进程管理软件)的方式管理</strong>"><strong>按照termcaps-HTOP(Linux下的系统监控与进程管理软件)的方式管理</strong></h3>
<p>通过<code>pm2 list</code>命令来观察所有运行的进程以及它们的状态已经足够好了.但是怎么来追踪它们的资源消耗呢?别担心,用这个命令:</p>
<pre><code><span class="variable">$ </span>pm2 monit
</code></pre><p>你可以得到进程(以及集群)的CPU的使用率和内存占用.</p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-monit.png" alt="pm2-monit"></p>
<p><strong>声明:</strong><a href="https://github.com/arunoda/node-usage" target="_blank">node-usage</a>到目前为止还不支持MacOS(随便什么性能要求),不过它在Linux下运行良好.</p>
<p>现在,让我们来核实一下我们的集群,还有对内存堆栈的垃圾回收,我们假设你已经有一个HTTP基准测试工具(如果没有,你一定要使用<a href="https://github.com/wg/wrk" target="_blank">WRK</a>):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    $ express bufallo    <span class="comment">//Create an express app</span>
    $ cd bufallo
    $ npm install
    $ pm2 start app<span class="built_in">.</span>js <span class="attribute">-i</span> <span class="keyword">max</span>
    $ wrk <span class="attribute">-c</span> <span class="number">100</span> <span class="attribute">-d</span> <span class="number">100</span> http:<span class="comment">//localhost:3000/</span>
</pre></td></tr></table></figure>

<p>在另一个终端,运行监控选项:</p>
<pre><code><span class="variable">$ </span>pm2 monit
</code></pre><p>耶~</p>
<h3 id="<strong>实时集中log处理</strong>"><strong>实时集中log处理</strong></h3>
<p>现在你不得不管理多个集群进程:一个爬取数据,一个处理数据,等等…这就意味着大量log,你可以按照老式的方法处理:</p>
<pre><code>$ tail -f /path/to/log1 /path/to/log2 <span class="keyword">...</span>
</code></pre><p>但我们想的很周到,我们增加了<code>logs</code>功能:</p>
<pre><code><span class="variable">$ </span>pm2 logs
</code></pre><p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-logs.png" alt="pm2-logs"></p>
<h3 id="<strong>快速恢复</strong>"><strong>快速恢复</strong></h3>
<p>现在事情一切顺利,你的进程嗡嗡的运行着,你需要做一次硬重启(hard restart).现在吗?是的,首先,dump掉:</p>
<pre><code><span class="variable">$ </span>pm2 dump
</code></pre><p>然后,你可以从文件中恢复它:</p>
<pre><code>$ pm2 <span class="built_in">kill</span>     <span class="comment"> //让我们假设一个PM2停掉了</span>
$ pm2 resurect <span class="comment"> //我所有的进程又满血满状态复活了</span>
</code></pre><h3 id="<strong>强健的API</strong>"><strong>强健的API</strong></h3>
<p>比方说,你想要监控所有被PM2管理的进程,而且同时还想监控运行这些进程的机器的状态(甚至希望创建一个Angular应用来调用这些API…):</p>
<pre><code><span class="variable">$ </span>pm2 web
</code></pre><p>打开浏览器输入<a href="http://localhost:9615" target="_blank">http://localhost:9615</a> ,我嘞个去!</p>
<h3 id="<strong>对了,还有很多特性…</strong>"><strong>对了,还有很多特性…</strong></h3>
<ul>
<li>全部测试通过,</li>
<li>新一代的<code>update-rc.d</code>(<code>pm2 startup</code>),当然它还是alpha版,</li>
<li>开发模式下更改文件自动重启(<code>pm2 dev</code>),也同样还是草稿,</li>
<li>自动刷新log,</li>
<li>快捷的通过JSON文件管理你的应用,</li>
<li>在error log里记录未捕获的异常,</li>
<li>记录重启的次数和时间,</li>
<li>退出时自动杀死进程.</li>
</ul>
<h2 id="<strong>下一步计划?</strong>"><strong>下一步计划?</strong></h2>
<p>首先,你可以去<a href="https://github.com/Unitech/pm2" target="_blank">Github上</a>粉我们(我们喜欢stars).</p>
<p>我们开发的PM2提供了先进完整的Node进程管理解决方案.我们希望能有更多的人来帮助我们:更多的pull requests.一些还停留在开发路线图上面的功能我们会尽快完成,下面这些就是:</p>
<ul>
<li>远程管理/状态校验,</li>
<li>嵌入式跨进程通信通道(消息总线),</li>
<li>V8垃圾回收的内存泄漏检查,</li>
<li>Web界面,</li>
<li>监控数据持久化,</li>
<li>邮件通知.</li>
</ul>
<p>特别感谢<a href="https://github.com/makara" target="_blank">Makara Wang</a>的观点和工具,还有<a href="https://github.com/rlidwka" target="_blank">Alex Kocharin</a>提的建议和提交的代码.</p>
<ul>
<li>在<a href="https://twitter.com/intent/tweet?text=@devo_ps%20&amp;related=devo_ps&amp;url=http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Twitter</a>上给我们反馈吧.</li>
<li>欢迎在<a href="http://news.ycombinator.com/item?id=5945420" target="_blank">Hacker News</a>上和我们一起谈论</li>
</ul>
<p>本博客基于<a href="http://zespia.tw/hexo/zh-CN/" target="_blank">hexo</a>搭建,推荐一个不错的主题<a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a>,虽然我还没用上,不过可以去<a href="http://yangjian.me" target="_blank">@A-limon</a>的主页查看效果.</p>
<p>最后感谢<a href="http://weibo.com/436062867" target="_blank">@A-limon</a>同学提供翻译建议和审读.</p>
]]></content>
    
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="PM2" scheme="http://se77en.cc/tags/PM2/"/>
    
      <category term="node.js" scheme="http://se77en.cc/categories/node.js/"/>
    
  </entry>
  
</feed>
