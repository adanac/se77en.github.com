<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AriesDevil's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://se77en.cc/"/>
  <updated>2014-04-09T06:56:11.593Z</updated>
  <id>http://se77en.cc/</id>
  
  <author>
    <name><![CDATA[Damon Zhao]]></name>
    <email><![CDATA[se77en.cc@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[基于 Martini 的跨域资源共享(CORS)]]></title>
    <link href="http://se77en.cc/2014/04/09/cors-with-martini-and-golang/"/>
    <id>http://se77en.cc/2014/04/09/cors-with-martini-and-golang/</id>
    <published>2014-04-09T00:00:00.000Z</published>
    <updated>2014-04-09T06:55:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p><a href="http://www.w3.org/TR/cors/" target="_blank">CORS</a> 的全称是 Cross-Origin Resource Sharing，即：跨域资源共享</p>
<p>根据我的理解，就是马伊琍和文章结婚了，姚笛就不能和文章结了，如果还想在一起，那就得采用一定的方法，这个方法就是跨域，哦，不对，是当第三者:)</p>
<p>根据维基百科的解释，CORS 是一种机制，这个机制允许一个 Web 页面上 JavaScript 向另外的域发起 XMLHttpRequests 请求，注意不是向该 Web 页面所在域请求。这样的跨域请求，在 CORS 之前，根据同源安全策略是会被浏览器拒绝的。CORS 定义了一种方法，这个方法使浏览器和服务器相互作用来限定是否允许跨域请求。它显然比只有单纯的同源请求有用，而且还比简单的允许所有跨域访问要安全。</p>
<p>在 CORS 出现之前，已经有了很多种方法来实现跨域访问，其中最有名的就是 JSONP(JSON with Padding)，JSONP 是一种使用 JavaScript 请求其它域服务器的一种通信技术，本质就是利用同源策略的漏洞，一般来说位于 xxoo.se77en.cc 的网页是无法与非 xxoo.se77en.cc 的服务器通信的，但是 HTML 里的 <code>&lt;script&gt;</code> 元素是一个例外，利用这一例外，可以通过 JavaScript 操作浏览器页面 DOM 来动态创建 Script 对象，再将 Script 的 src 属性指向另一个域的资源，服务器就会将数据伪装成一段 JavaScript 代码来实现跨域目的。不过这种技术只能发起 GET 请求，而且安全隐患极大，因为远程服务器可以发送 JavaScript 代码，所以极易受到跨网站伪造请求(CSRF/XSRF)，所以使用 JSONP 要格外小心。</p>
<blockquote>
<p>注：目前有个正在进行的计划定义 <a href="http://json-p.org/" target="_blank">JSON-P 严格安全子集</a>，使浏览器可以对 MIME 类别是 <code>application/json-p</code> 的请求做强制处理，如果不能被解析为严格的 JSON-P，浏览器则会抛出一个错误或者忽略整个响应，目前正确的 JSONP MIME 类型仍然是 <code>application/javascript</code></p>
</blockquote>
<p>对比 JSONP 的限制，CORS 的限制主要是浏览器支持的问题(不过已经很不错了，除了万恶的 IE6)：</p>
<p><img src="/img/cors-with-martini-and-golang/cors-in-broswer.png" alt="cors-in-broswer"></p>
<h2 id="创建一个_CORS_请求">创建一个 CORS 请求</h2>
<p>完成一个 CORS 需要前后端配合。</p>
<h3 id="前端">前端</h3>
<p>对前端而言，基本没什么变化，还是使用 XMLHttpRequest 对象(IE 使用 XDomainRequest)，增加了参数和响应回调，当然如果你用 jQuery 可以不用考虑这么多了。下面用 JavaScript 和 jQuery 分别示例：</p>
<p>首先是 JavaScript，比较复杂，所以直接用大牛 Nicholas•Zakas 写的帮助方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) {

    <span class="comment">// 检查 XMLHttpRequest 对象是否包含 "withCredentials" 属性</span>
    <span class="comment">// "withCredentials" 只在 XMLHTTPRequest2 对象中存在</span>
    xhr.open(method, url, <span class="literal">true</span>);

  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>) {

    <span class="comment">// 否则，检查是否是 XDomainRequest</span>
    <span class="comment">// XDomainRequest 只在 IE 中存在, 所以用 IE 的方式来创建 CORS 请求</span>
    xhr = <span class="keyword">new</span> XDomainRequest();
    xhr.open(method, url);

  } <span class="keyword">else</span> {

    <span class="comment">// 上述都不满足，说明浏览器不支持 CORS</span>
    xhr = <span class="literal">null</span>;

  }
  <span class="keyword">return</span> xhr;
}

<span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
<span class="keyword">if</span> (!xhr) {
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CORS not supported'</span>);
}
</pre></td></tr></table></figure>

<p>如果你想要提交 cookies 需要设置 XMLHttpRequest 的 withCredentials 属性为 true：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xhr.withCredentials = <span class="literal">true</span>;
</pre></td></tr></table></figure>

<p>然后处理服务端的返回结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
 <span class="keyword">var</span> responseText = xhr.responseText;
 console.log(responseText);
 <span class="comment">// 处理返回结果</span>
};

xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  console.log(<span class="string">'There was an error!'</span>);
};
</pre></td></tr></table></figure>

<p>坑爹的是，浏览器在发生错误时的处理方式并不好，FireFox 对于所有错误返回一个为0的状态值和一个空的信息。浏览器会在 console log 里打印一个错误信息，不过这个信息却不能被 JavaScript 访问。所以处理错误时，你只知道一个错误发生了，别的一概不知。</p>
<p>前端完整代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="comment">// 创建 XHR 对象</span>
<span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span><span class="params">(method, url)</span> {</span>
  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();
  <span class="keyword">if</span> (<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr) {
    <span class="comment">// XHR for Chrome/Firefox/Opera/Safari.</span>
    xhr.open(method, url, <span class="literal">true</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>) {
    <span class="comment">// XDomainRequest for IE.</span>
    xhr = <span class="keyword">new</span> XDomainRequest();
    xhr.open(method, url);
  } <span class="keyword">else</span> {
    <span class="comment">// 不支持 CORS</span>
    xhr = <span class="literal">null</span>;
  }
  <span class="keyword">return</span> xhr;
}


<span class="comment">//创建真正的一个 CORS 请求</span>
<span class="function"><span class="keyword">function</span> <span class="title">makeCorsRequest</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> url = <span class="string">'http://ooxx.se77en.cc'</span>;

  <span class="keyword">var</span> xhr = createCORSRequest(<span class="string">'GET'</span>, url);
  <span class="keyword">if</span> (!xhr) {
    alert(<span class="string">'CORS not supported'</span>);
    <span class="keyword">return</span>;
  }

  <span class="comment">// 处理响应</span>
  xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> text = xhr.responseText;
    alert(<span class="string">'Response from CORS request to '</span> + url);
  };

  xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    alert(<span class="string">'Woops, there was an error making the request.'</span>);
  };

  xhr.send();
}
</pre></td></tr></table></figure>

<h3 id="服务端">服务端</h3>
<p>对服务端而言，最简单的处理方法就是增加下面一行到你的 Response Header 里：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: <span class="subst">*</span>
</pre></td></tr></table></figure>

<p>使用 go 来实现就是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>func setAllowOrigin(writer http<span class="preprocessor">.ResponseWriter</span>, r *http<span class="preprocessor">.Request</span>) {
  writer<span class="preprocessor">.Header</span>()<span class="preprocessor">.Add</span>(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>)
  return
}
</pre></td></tr></table></figure>

<p>当然，如果希望处理 POST，PUT 这类复杂的请求，或者是想要更加精确的控制 CORS，如：允许的域范围，是否允许 Cookie，允许哪些请求方法，那自然处理也会变得复杂一点。</p>
<p>对于任何非简单请求，浏览器都会先于服务器进行沟通，达成一致后，再发出实际请求。沟通的方式叫做 Preflight(起飞预备)，在发起实际请求前，浏览器首先通过 OPTIONS 方式(这样才能从服务器收到响应)。</p>
<p>Preflight 请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>OPTIONS /cors HTTP/<span class="number">1.1</span>
Origin: http:<span class="comment">//ooxx.se77en.cc</span>
Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> POST, PUT
Access-Control-Request-Headers: X-Custom-Header
</pre></td></tr></table></figure>

<ul>
<li><code>Access-Control-Request-Method</code> 是浏览器要发出的请求类型</li>
<li><code>Access-Control-Request-Headers</code> 是实际请求发送过来时额外的 Header 类型</li>
</ul>
<p>以上这些参数都是可以用逗号分隔的多值字符串。</p>
<p>Preflight 响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: http:<span class="comment">//ooxx.se77en.cc</span>
Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Methods</span>: GET, POST, PUT
Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Headers</span>: X<span class="attribute">-Custom</span><span class="attribute">-Header</span>
Content<span class="attribute">-Type</span>: text/html; charset<span class="subst">=</span>utf<span class="subst">-</span><span class="number">8</span>
</pre></td></tr></table></figure>

<ul>
<li><code>Access-Control-Allow-Origin</code> 是 CORS 响应的标配</li>
<li><code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 是服务器支持的方法和头信息，值得注意的是，这里应该填写全集，而非对应 Preflight 请求里的项目</li>
</ul>
<p>此外还有一些可选项：</p>
<ul>
<li><code>Access-Control-Max-Age</code> 是告诉浏览器多少秒以内，不再需要请求 Preflight</li>
<li><code>Access-Control-Allow-Credentials</code> 是告诉浏览器是否支持 Cookie，对应上面</li>
</ul>
<p>Preflight 沟通失败：</p>
<p>如果 Preflight 发送过来的请求权限超过了服务器所支持的，回复的方法是忽略掉 <code>Access-Control-Allow-Origin</code> 即可，就像一个普通的 HTTP 200 返回，这样浏览器就不会发起实际请求了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span>
</pre></td></tr></table></figure>

<p>沟通成功后的实际请求和响应：</p>
<p>当浏览器发起 Preflight，并确认服务器支持 CORS 无误，就可以发起实际请求步骤</p>
<p>实际请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="request">POST <span class="string">/cors</span> HTTP/1.1</span>
<span class="attribute">Origin</span>: <span class="string">http://ooxx.se77en.cc</span>
<span class="attribute">Host</span>: <span class="string">xxoo.wisteria.io</span>
<span class="attribute">X-Custom-Header</span>: <span class="string">value</span>
<span class="attribute">Accept-Language</span>: <span class="string">en-US</span>
<span class="attribute">Connection</span>: <span class="string">keep-alive</span>
<span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0...</span>
</pre></td></tr></table></figure>

<p>实际响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>Access<span class="attribute">-Control</span><span class="attribute">-Allow</span><span class="attribute">-Origin</span>: http:<span class="comment">//ooxx.se77en.cc</span>
Content<span class="attribute">-Type</span>: text/html; charset<span class="subst">=</span>utf<span class="subst">-</span><span class="number">8</span>
</pre></td></tr></table></figure>

<p>交互过程：</p>
<p><img src="/img/cors-with-martini-and-golang/cors_flow.png" alt="cors_flow"></p>
<p>服务端响应流程图：</p>
<p><img src="/img/cors-with-martini-and-golang/cors_server_flowchart.png" alt="cors_server_flowchart"></p>
<h3 id="如何用_Go_语言实现？">如何用 Go 语言实现？</h3>
<p>按照上述过程，首先判断是 Preflight 还是 Actual Request：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>func (cors *Cors) ServeHTTP(w <span class="keyword">http</span>.ResponseWriter, r *<span class="keyword">http</span>.Request) {
  <span class="keyword">if</span> origin := r.Header.Get(<span class="string">"Origin"</span>); origin == <span class="string">""</span> {
      cors.corsNotValid(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> r.Method != <span class="string">"OPTIONS"</span> {
     <span class="comment"> //actual request.</span>
      cors.actualRequest(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> acrm := r.Header.Get(<span class="string">"Access-Control-Request-Method"</span>); acrm == <span class="string">""</span> {
     <span class="comment"> //actual request.</span>
      cors.actualRequest(w, r)
      <span class="constant">return</span>
  } <span class="keyword">else</span> {
     <span class="comment"> //preflight request.</span>
      cors.preflightRequest(w, r)
      <span class="constant">return</span>
  }
}
</pre></td></tr></table></figure>

<h3 id="在_Martini_中实现">在 Martini 中实现</h3>
<p>上面代码只是说明意图，下面我们来示范一下 CORS 在 Martini 中的应用。</p>
<p>首先是页面所在域，假设为 xxoo.wisteria.io</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://cdn.staticfile.org/jquery/1.8.2/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">
    $(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      $(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
        e.preventDefault();  <span class="comment">//感谢 @A-limon 提醒</span>
        <span class="keyword">var</span> btx = $(<span class="string">"#btx"</span>).val();
        <span class="keyword">var</span> url = <span class="string">"http://ooxx.se77en.cc/cors"</span>;
        $.ajax(url, {
          type:<span class="string">"POST"</span>,
          data:{<span class="string">"value"</span>:btx},
          dataType:<span class="string">"json"</span>,
          xhrFields:{
            withCredentials:<span class="literal">false</span>
          },
          success:<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>alert(data.msg);},
          error:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>alert(<span class="string">"errror"</span>);}
        });
      });
    });
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
  <span class="tag">&lt;<span class="title">h1</span>&gt;</span>CORS<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
  <span class="tag">&lt;<span class="title">form</span>&gt;</span>
    <span class="tag">&lt;<span class="title">textarea</span> <span class="attribute">id</span>=<span class="value">"btx"</span> <span class="attribute">cols</span>=<span class="value">"30"</span> <span class="attribute">rows</span>=<span class="value">"10"</span>&gt;</span><span class="tag">&lt;/<span class="title">textarea</span>&gt;</span><span class="tag">&lt;<span class="title">br</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"btn"</span>&gt;</span>submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">form</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<p>接下来是服务器所在域，假设为 ooxx.se77en.cc</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>package main

import (
	<span class="string">"github.com/go-martini/martini"</span>
	<span class="string">"github.com/martini-contrib/binding"</span>
	<span class="string">"github.com/martini-contrib/cors"</span>
)

type xxoo struct {
	Value string `form:<span class="string">"value"</span>`
}

func main() {
	m := martini.Classic()
	m.Use(cors.Allow(&cors.Options{
		AllowOrigins:     []string{<span class="string">"http://xxoo.wisteria.io"</span>},
		AllowMethods:     []string{<span class="string">"POST"</span>},
		AllowHeaders:     []string{<span class="string">"Origin"</span>, <span class="string">"x-requested-with"</span>, <span class="string">"Content-Type"</span>, <span class="string">"Content-Range"</span>, <span class="string">"Content-Disposition"</span>, <span class="string">"Content-Description"</span>},
		ExposeHeaders:    []string{<span class="string">"Content-Length"</span>},
		AllowCredentials: false,
	}))

	m.Post(<span class="string">"/cors"</span>, binding.Form(xxoo{}), func(ooxx xxoo, writer http.ResponseWriter) (int, string) {
		writer.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)
		log.Println(<span class="string">"******* "</span> + ooxx.Value + <span class="string">" *******"</span>)
		return http.StatusOK, `{<span class="string">"msg"</span>:<span class="string">"hello cors"</span>}`
	})
	
  m.Run()
}
</pre></td></tr></table></figure>

<p>可以看到 Martini 的 cors 插件已经为我们做了很多工作，详细说明请参见 <a href="https://github.com/martini-contrib/cors#usage" target="_blank">cors 文档</a>。</p>
<h2 id="感谢">感谢</h2>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing" target="_blank">http://en.wikipedia.org/wiki/Cross-origin_resource_sharing</a></li>
<li><a href="http://en.wikipedia.org/wiki/JSONP" target="_blank">http://en.wikipedia.org/wiki/JSONP</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/cors/" target="_blank">http://www.html5rocks.com/en/tutorials/cors/</a></li>
<li><a href="http://semicircle.github.io/blog/2013/09/29/go-with-cors/" target="_blank">http://semicircle.github.io/blog/2013/09/29/go-with-cors/</a></li>
<li><a href="http://client.cors-api.appspot.com/client" target="_blank">http://client.cors-api.appspot.com/client</a></li>
<li><a href="http://enable-cors.org/" target="_blank">http://enable-cors.org/</a></li>
</ol>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="cors" scheme="http://se77en.cc/tags/cors/"/>
    
      <category term="martini" scheme="http://se77en.cc/tags/martini/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Go 语言的并发模型--通过通信来共享内存]]></title>
    <link href="http://se77en.cc/2014/04/08/share-by-communicating-the-concurrency-slogan-in-golang/"/>
    <id>http://se77en.cc/2014/04/08/share-by-communicating-the-concurrency-slogan-in-golang/</id>
    <published>2014-04-08T00:00:00.000Z</published>
    <updated>2014-04-09T06:27:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2>
<p>我一直在找一种好的方法来解释 go 语言的<a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank">并发模型</a>：</p>
<blockquote>
<p>不要通过共享内存来通信，相反，应该通过通信来共享内存</p>
</blockquote>
<p>但是没有发现一个好的解释来满足我下面的需求：</p>
<ul>
<li>通过一个例子来说明最初的问题</li>
<li>提供一个共享内存的解决方案</li>
<li>提供一个通过通信的解决方案</li>
</ul>
<p>这篇文章我就从这三个方面来做出解释。</p>
<p>读过这篇文章后你应该会了解<strong><em>通过通信来共享内存</em></strong>的模型，以及它和<strong><em>通过共享内存来通信</em></strong>的区别，你还将看到如何分别通过这两种模型来解决访问和修改共享资源的问题。</p>
<h2 id="前提">前提</h2>
<p>设想一下我们要访问一个银行账号：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">type</span> Account <span class="keyword">interface</span> {
  Withdraw(<span class="typename">uint</span>)
  Deposit(<span class="typename">uint</span>)
  Balance() <span class="typename">int</span>
}

<span class="keyword">type</span> Bank <span class="keyword">struct</span> {
  account Account
}

<span class="keyword">func</span> NewBank(account Account) *Bank {
  <span class="keyword">return</span> &Bank{account: account}
}

<span class="keyword">func</span> (bank *Bank) Withdraw(amount <span class="typename">uint</span>, actor_name <span class="typename">string</span>) {
  fmt.Println(<span class="string">"[-]"</span>, amount, actor_name)
  bank.account.Withdraw(amount)
}

<span class="keyword">func</span> (bank *Bank) Deposit(amount <span class="typename">uint</span>, actor_name <span class="typename">string</span>) {
  fmt.Println(<span class="string">"[+]"</span>, amount, actor_name)
  bank.account.Deposit(amount)
}

<span class="keyword">func</span> (bank *Bank) Balance() <span class="typename">int</span> {
  <span class="keyword">return</span> bank.account.Balance()
}
</pre></td></tr></table></figure>

<p>因为 <code>Account</code> 是一个接口，所以我们提供一个简单的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="keyword">type</span> SimpleAccount <span class="keyword">struct</span>{
  balance <span class="typename">int</span>
}

<span class="keyword">func</span> NewSimpleAccount(balance <span class="typename">int</span>) *SimpleAccount {
  <span class="keyword">return</span> &SimpleAccount{balance: balance}
}

<span class="keyword">func</span> (acc *SimpleAccount) Deposit(amount <span class="typename">uint</span>) {
  acc.setBalance(acc.balance + <span class="typename">int</span>(amount))
}

<span class="keyword">func</span> (acc *SimpleAccount) Withdraw(amount <span class="typename">uint</span>) {
  <span class="keyword">if</span> acc.balance &gt;= <span class="typename">int</span>(mount) {
    acc.setBalance(acc.balance - <span class="typename">int</span>(amount))
  } <span class="keyword">else</span> {
    <span class="built_in">panic</span>(<span class="string">"杰克穷死"</span>)
  }
}

<span class="keyword">func</span> (acc *SimpleAccount) Balance() <span class="typename">int</span> {
  <span class="keyword">return</span> acc.balance
}

<span class="keyword">func</span> (acc *SimpleAccount) setBalance(balance <span class="typename">int</span>) {
  acc.add_some_latency()  <span class="comment">//增加一个延时函数，方便演示</span>
  acc.balance = balance
}

<span class="keyword">func</span> (acc *SimpleAccount) add_some_latency() {
  &lt;-time.After(time.Duration(rand.Intn<span class="number">(100</span>)) * time.Millisecond)
}
</pre></td></tr></table></figure>

<p>你可能注意到了 <code>balance</code> 没有被直接修改，而是被放到了  <code>setBalance</code> 方法里进行修改。这样设计是为了更好的描述问题。稍后我会做出解释。</p>
<p>把上面所有部分弄好以后我们就可以像下面这样使用它啦：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">func</span> <span class="tag">main</span>() <span class="rules">{
  <span class="rule"><span class="attribute">balance </span>:<span class="value">= <span class="number">80</span>
  b := bank.<span class="function">NewBank(bank.<span class="function">NewSimpleAccount(balance)</span>)</span>
  
  fmt.<span class="function">Println(<span class="string">"初始化余额"</span>, b.<span class="function">Balance()</span>)</span>
  
  b.<span class="function">Withdraw(<span class="number">30</span>, <span class="string">"马伊琍"</span>)</span>
  
  fmt.<span class="function">Println(<span class="string">"-----------------"</span>)</span>
  fmt.<span class="function">Println(<span class="string">"剩余余额"</span>, b.<span class="function">Balance()</span>)</span>
</span></span></span>}
</pre></td></tr></table></figure>

<p>运行上面的代码会输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
-<span class="ruby">----------------
</span>剩余余额 50
</pre></td></tr></table></figure>

<p>没错！</p>
<p>不错在现实生活中，一个银行账号可以有很多个附属卡，不同的附属卡都可以对同一个账号进行存取钱，所以我们来修改一下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">func</span> main() {
  balance :=<span class="number"> 80</span>
  b := bank.NewBank(bank.NewSimpleAccount(balance))
  
  fmt.Println(<span class="string">"初始化余额"</span>, b.Balance())
  
  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)
  
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(30</span>, <span class="string">"马伊琍"</span>); done &lt;- <span class="constant">true</span> }()
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(10</span>, <span class="string">"姚笛"</span>); done &lt;- <span class="constant">true</span> }()
  
  <span class="comment">//等待 goroutine 执行完成</span>
  &lt;-done
  &lt;-done
  
  fmt.Println(<span class="string">"-----------------"</span>)
  fmt.Println(<span class="string">"剩余余额"</span>, b.Balance())
}
</pre></td></tr></table></figure>

<p>这儿两个附属卡并发的从账号里取钱，来看看输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 70
</pre></td></tr></table></figure>

<p>这下把文章高兴坏了:)</p>
<p>结果当然是错误的，剩余余额应该是40而不是70，那么让我们看看到底哪儿出问题了。</p>
<h2 id="问题">问题</h2>
<p>当并发访问共享资源时，无效状态有很大可能会发生。</p>
<p>在我们的例子中，当两个附属卡同一时刻从同一个账号取钱后，我们最后得到银行账号(即共享资源)错误的剩余余额(即无效状态)。</p>
<p>我们来看一下执行时候的情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>                 处理情况
             --------------
             _马伊琍_|_姚笛_
 <span class="number">1.</span> 获取余额     <span class="number">80</span>  |  <span class="number">80</span>
 <span class="number">2.</span> 取钱       -<span class="number">30</span>  | -<span class="number">10</span>
 <span class="number">3.</span> 当前剩余     <span class="number">50</span>  |  <span class="number">70</span>
                <span class="keyword">...</span> | <span class="keyword">...</span>
 <span class="number">4.</span> 设置余额     <span class="number">50</span>  ?  <span class="number">70</span>  //该先设置哪个好呢？
 <span class="number">5.</span> 后设置的生效了
             --------------
 <span class="number">6.</span> 剩余余额        <span class="number">70</span>
</pre></td></tr></table></figure>

<p>上面 <code>...</code> 的地方描述了我们 <code>add_some_latency</code> 实现的延时状况，现实世界经常发生延迟情况。所以最后的剩余余额就由最后设置余额的那个附属卡决定。</p>
<h2 id="解决办法">解决办法</h2>
<p>我们通过两种方法来解决这个问题：</p>
<ul>
<li>共享内存的解决方案</li>
<li>通过通信的解决方案</li>
</ul>
<p>所有的解决方案都是简单的封装了一下 <code>SimpleAccount</code> 来实现保护机制。</p>
<h3 id="共享内存的解决方案">共享内存的解决方案</h3>
<p>又叫 “通过共享内存来通信”。</p>
<p>这种方案暗示了使用锁机制来预防同时访问和修改共享资源。锁告诉其它处理程序这个资源已经被一个处理程序占用了，因此别的处理程序需要排队直到当前处理程序处理完毕。</p>
<p>让我们来看看 <code>LockingAccount</code> 是怎么实现的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>type LockingAccount struct {
  lock    sync<span class="preprocessor">.Mutex</span>
  account *SimpleAccount
}

//封装一下 SimpleAccount
func NewLockingAccount(balance int) *LockingAccount {
  return &LockingAccount{account: NewSimpleAccount(balance)}
}

func (acc *LockingAccount) Deposit(amount uint) {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  acc<span class="preprocessor">.account</span><span class="preprocessor">.Deposit</span>(amount)
}

func (acc *LockingAccount) Withdraw(amount uint) {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  acc<span class="preprocessor">.account</span><span class="preprocessor">.Withdraw</span>(amount)
}

func (acc *LockingAccount) Balance() int {
  acc<span class="preprocessor">.lock</span><span class="preprocessor">.Lock</span>()
  defer acc<span class="preprocessor">.lock</span><span class="preprocessor">.Unlock</span>()
  return acc<span class="preprocessor">.account</span><span class="preprocessor">.Balance</span>()
}
</pre></td></tr></table></figure>

<p>直接明了！注意 <code>lock sync.Lock</code>，<code>lock.Lock()</code>，<code>lock.Unlock()</code>。</p>
<p>这样每次一个附属卡访问银行账号(即共享资源)，这个附属卡会自动获得锁直到最后操作完毕。</p>
<p>我们的 <code>LockingAccount</code> 像下面这样使用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">func</span> main() {
  balance :=<span class="number"> 80</span>
  b := bank.NewBank(bank.NewLockingAccount(balance))
  
  fmt.Println(<span class="string">"初始化余额"</span>, b.Balance())
  
  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">bool</span>)
  
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(30</span>, <span class="string">"马伊琍"</span>); done &lt;- <span class="constant">true</span> }()
  <span class="keyword">go</span> <span class="keyword">func</span>() { b.Withdraw<span class="number">(10</span>, <span class="string">"姚笛"</span>); done &lt;- <span class="constant">true</span> }()
  
  <span class="comment">//等待 goroutine 执行完成</span>
  &lt;-done
  &lt;-done
  
  fmt.Println(<span class="string">"-----------------"</span>)
  fmt.Println(<span class="string">"剩余余额"</span>, b.Balance())
}
</pre></td></tr></table></figure>

<p>输出的结果是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 40
</pre></td></tr></table></figure>

<p>现在结果正确了！</p>
<p>在这个例子中第一个处理程序加锁后独享共享资源，其它处理程序只能等待它执行完成。</p>
<p>我们接着看一下执行时的情况，假设马伊琍先拿到了锁：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>                            处理过程
                        ________________
                        _马伊琍_|__姚笛__
        加锁                   &gt;&lt;
        得到余额            <span class="number">80</span>  |
        取钱               -<span class="number">30</span>  |
        当前余额            <span class="number">50</span>  |
                           <span class="keyword">...</span> |
        设置余额            <span class="number">50</span>  |
        解除锁                 &lt;&gt;
                               |
        当前余额                <span class="number">50</span>
                               |
        加锁                   &gt;&lt;
        得到余额                |  <span class="number">50</span>
        取钱                    | -<span class="number">10</span>
        当前余额                |  <span class="number">40</span>
                               |  <span class="keyword">...</span>
        设置余额                |  <span class="number">40</span>
        解除锁                  &lt;&gt;
                        ________________
        剩余余额                <span class="number">40</span>
</pre></td></tr></table></figure>

<p>现在我们的处理程序在访问共享资源时相继的产生了正确的结果。</p>
<h3 id="通过通信的解决方案">通过通信的解决方案</h3>
<p>又叫 “通过通信来共享内存”。</p>
<p>现在账号被命名为 <code>ConcurrentAccount</code>，像下面这样来实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="keyword">type</span> ConcurrentAccount <span class="keyword">struct</span> {
  account     *SimpleAccount
  deposits    <span class="keyword">chan</span> <span class="typename">uint</span>
  withdrawals <span class="keyword">chan</span> <span class="typename">uint</span>
  balances    <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="typename">int</span>
}

<span class="keyword">func</span> NewConcurrentAccount(amount <span class="typename">int</span>) *ConcurrentAccount{
  acc := &ConcurrentAccount{
    account :    &SimpleAccount{balance: amount},
    deposits:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">uint</span>),
    withdrawals: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">uint</span>),
    balances:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="typename">int</span>),
  }
  acc.listen()
  
  <span class="keyword">return</span> acc
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Balance() <span class="typename">int</span> {
  ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)
  acc.balances &lt;- ch
  <span class="keyword">return</span> &lt;-ch
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Deposit(amount <span class="typename">uint</span>) {
  acc.deposits &lt;- amount
}

<span class="keyword">func</span> (acc *ConcurrentAccount) Withdraw(amount <span class="typename">uint</span>) {
  acc.withdrawals &lt;- amount
}

<span class="keyword">func</span> (acc *ConcurrentAccount) listen() {
  <span class="keyword">go</span> <span class="keyword">func</span>() {
    <span class="keyword">for</span> {
      <span class="keyword">select</span> {
      <span class="keyword">case</span> amnt := &lt;-acc.deposits:
        acc.account.Deposit(amnt)
      <span class="keyword">case</span> amnt := &lt;-acc.withdrawals:
        acc.account.Withdraw(amnt)
      <span class="keyword">case</span> ch := &lt;-acc.balances:
        ch &lt;- acc.account.Balance()
      }
    }
  }()
}
</pre></td></tr></table></figure>

<p><code>ConcurrentAccount</code> 同样封装了 <code>SimpleAccount</code> ，然后增加了通信通道</p>
<p>调用代码和加锁版本的一样，这里就不写了，唯一不一样的就是初始化银行账号的时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>b := bank<span class="preprocessor">.NewBank</span>(bank<span class="preprocessor">.NewConcurrentAccount</span>(balance))
</pre></td></tr></table></figure>

<p>运行产生的结果和加锁版本一样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>初始化余额 80
[-] 30 马伊琍
[-] 10 姚笛
-<span class="ruby">----------------
</span>剩余余额 40
</pre></td></tr></table></figure>

<p>让我们来深入了解一下细节。</p>
<h3 id="通过通信来共享内存是如何工作的">通过通信来共享内存是如何工作的</h3>
<p>一些基本注意点：</p>
<ul>
<li>共享资源被封装在一个控制流程中。<br>结果就是资源成为了非共享状态。没有处理程序能够直接访问或者修改资源。你可以看到访问和修改资源的方法实际上并没有执行任何改变。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  <span class="keyword">func</span> (acc *ConcurrentAccount) Balance() <span class="typename">int</span> {
    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="typename">int</span>)
    acc.balances &lt;- ch
    balance := &lt;-ch
    <span class="keyword">return</span> balance
  }
  <span class="keyword">func</span> (acc *ConcurrentAccount) Deposit(amount <span class="typename">uint</span>) {
    acc.deposits &lt;- amount
  }

  <span class="keyword">func</span> (acc *ConcurrentAccount) Withdraw(amount <span class="typename">uint</span>) {
    acc.withdrawals &lt;- amount
  }
</pre></td></tr></table></figure>


<ul>
<li>访问和修改是通过消息和控制流程通信。</li>
<li>在控制流程中任何访问和修改的动作都是相继发生的。<br>当控制流程接收到访问或者修改的请求后会立即执行相关动作。让我们仔细看看这个流程：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>  func (acc *ConcurrentAccount) listen() {
    // 执行控制流程
    go func() {
      for {
        select {
        case amnt := &lt;-acc<span class="preprocessor">.deposits</span>:
          acc<span class="preprocessor">.account</span><span class="preprocessor">.Deposit</span>(amnt)
        case amnt := &lt;-acc<span class="preprocessor">.withdrawals</span>:
          acc<span class="preprocessor">.account</span><span class="preprocessor">.Withdraw</span>(amnt)
        case ch := &lt;-acc<span class="preprocessor">.balances</span>:
          ch &lt;- acc<span class="preprocessor">.account</span><span class="preprocessor">.Balance</span>()
        }
      }
    }()
  }
</pre></td></tr></table></figure>


<p>  <a href="http://golang.org/ref/spec#Select_statements" target="_blank">select</a> 不断地从各个通道中取出消息，每个通道都跟它们所要执行的操作相一致。</p>
<p>  重要的一点是：在 <code>select</code> 声明内部的一切都是相继执行的(在同一个处理程序中排队执行)。一次只有一个事件(在通道中接受或者发送)发生，这样就保证了同步访问共享资源。</p>
<p>  领会这个有一点绕。</p>
<p>让我们用例子来看看 <code>Balance()</code> 的执行情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>         一张附属卡的流程      |   控制流程 
      <span class="comment">----------------------------------------------</span>

 <span class="number">1.</span>     b.<span class="type">Balance</span>()         |
 <span class="number">2.</span>             ch -&gt; [acc.balances]-&gt; ch
 <span class="number">3.</span>             &lt;-ch        |  balance = acc.account.<span class="type">Balance</span>()
 <span class="number">4.</span>     return  balance &lt;-[ch]&lt;- balance
 <span class="number">5</span>                          |
</pre></td></tr></table></figure>

<p>这两个流程都干了点什么呢？</p>
<h3 id="附属卡的流程">附属卡的流程</h3>
<ol>
<li>调用 <code>b.Balance()</code></li>
<li>新建通道 <code>ch</code>，将 <code>ch</code> 通道塞入通道 <code>acc.balances</code> 中与控制流程通信，这样控制流程也可以通过 <code>ch</code> 来返回余额</li>
<li>等待 <code>&lt;-ch</code> 来取得要接受的余额</li>
<li>接受余额</li>
<li>继续</li>
</ol>
<h3 id="控制流程">控制流程</h3>
<ol>
<li>空闲或者处理</li>
<li>通过 <code>acc.balances</code> 通道里面的 <code>ch</code> 通道来接受余额请求</li>
<li>取得真正的余额值</li>
<li>将余额值发送到 <code>ch</code> 通道</li>
<li>准备处理下一个请求</li>
</ol>
<p>控制流程每次只处理一个 <code>事件</code>。这也就是为什么除了描述出来的这些以外，第2-4步没有别的操作执行。</p>
<h2 id="总结">总结</h2>
<p>这篇博客描述了问题以及问题的解决办法，但那时没有深入去探究不同解决办法的优缺点。</p>
<p>下一篇中会详尽说明并且会改进解决方案。</p>
<p>请毫无顾忌的指出我的错误！</p>
]]></content>
    
    
      <category term="golang" scheme="http://se77en.cc/tags/golang/"/>
    
      <category term="concurrency" scheme="http://se77en.cc/tags/concurrency/"/>
    
      <category term="golang" scheme="http://se77en.cc/categories/golang/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Koa 从零打造 TODO 应用]]></title>
    <link href="http://se77en.cc/2014/02/05/koa-zero-to-todo-list-translation/"/>
    <id>http://se77en.cc/2014/02/05/koa-zero-to-todo-list-translation/</id>
    <published>2014-02-05T00:00:00.000Z</published>
    <updated>2014-02-05T09:36:22.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://blog.peterdecroos.com/blog/2014/02/01/koa-zero-to-todo-list/" target="_blank">Koa: Zero to Todo List</a></p>
<blockquote>
<h3 id="注意：你需要使用node_0-11-x外加_<code>-harmony</code>_来执行代码">注意：你需要使用node 0.11.x外加 <code>-harmony</code> 来执行代码</h3>
</blockquote>
<p>Express 团队利用新的 ECMAScript 6 的生成器语法创建了新的框架，<a href="http://koajs.com/" target="_blank">Koa</a> 框架是一个全新的 node web 框架，包含了很多有意思的东西。</p>
<h2 id="之前的方式">之前的方式</h2>
<p>在 node 标准库里，<code>http</code> 模块被用来创建服务。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> {</span>
  res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>});
  <span class="comment">//这里写服务逻辑</span>
  res.end(<span class="string">''</span>);
});

server.listen(<span class="number">3000</span>, <span class="string">'127.0.0.1'</span>);
console.log(<span class="string">'listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>Express 暴露一个方法使我们可以将 <code>http.createServer</code> 作为回调。Express 中间件是一个函数集合，每个函数包含了三个参数 <code>req</code>,<code>res</code>,<code>next</code>。中间件执行一些操作，修改请求或者返回对象然后通过调用 <code>next()</code> 来传递到堆栈里的下一个中间件。它类似一个瀑布模型，在中间件栈的底部结束响应。</p>
<h2 id="进入_Koa：建立在生成器机制上的框架">进入 Koa：建立在生成器机制上的框架</h2>
<p>就像 Express，Koa 也是生成一个可以被传递到 <code>http.createServer()</code> 的回调。与 Express 不同的是，它使用生成器提供一个更加细粒度的控制流程。</p>
<p>下面是一个最基本的 Koa 应用，用来读取一个文件的内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> koa      = <span class="keyword">require</span>(<span class="string">'koa'</span>);
<span class="keyword">var</span> Promise  = <span class="keyword">require</span>(<span class="string">'bluebird'</span>);

<span class="comment">//创建 promise 版本的 fs</span>
<span class="keyword">var</span> fs = Promise.promisifyAll(<span class="keyword">require</span>(<span class="string">'fs'</span>));
<span class="comment">//创建 koa 实例</span>
<span class="keyword">var</span> app = koa();

app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">(next)</span> {</span>
  <span class="comment">//这是一个示例中间件，在控制台记录一些东西</span>
  console.log(<span class="string">'timestamp: before request =&gt; '</span>, time.now());
  <span class="keyword">yield</span> next;
  console.log(<span class="string">'timestamp: after request =&gt; '</span>, time.now());
});

app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  this.body = <span class="keyword">yield</span> fs.readFileAsync(<span class="string">'./app.js'</span>, <span class="string">'utf8'</span>);
});

app.listen(<span class="number">3000</span>);
console.log(<span class="string">'now listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>不像 Express，Koa 中中间件使用生成器来编写。在 Koa 流中下游的中间件在返回时向上流动(回形针调用方式，具体参见：koajs.cn)。通过显式的调用 <code>yield next</code> 来执行下游中间件。当下游中间件返回时，控制流回溯到上游中间件。</p>
<p>Express 通过不同的函数来传递 node 原生的 req 和 res，Koa 则是通过讲它们装入一个借口来管理上下文。不过它们仍然可以通过 <code>this</code> 关键字获取到，像这样：<code>this.req</code>, <code>this.res</code>。然而，在文档中直接使用原生对象是不被推荐的。可以预测到当在控制流中调用 <code>this.res.end(&#39;&#39;)</code> 时会抛出一个 monkey wrench(猴子扳手？此处不会翻译欢迎指正)。所以建议你使用 <code>this.request</code> 和 <code>this.response</code> 来代替直接调用原生对象。很多方法都起了别名指向直接用 <code>this</code> 调用，比如：<code>this.body</code> 就是 <code>this.response.body</code> 的别名。</p>
<p>目前似乎还没有出现可以直接得到请求体的办法。co-body 分析器可以直接的解析请求体，不过文档说别这么做，Koa 是一个年轻的框架，所以别让你的手闲下来。</p>
<h2 id="使用_Koa_做一个_TODO_应用">使用 Koa 做一个 TODO 应用</h2>
<p>刚才我们已经简单的进行了介绍，现在来试着做一个复杂点的。一个 TODO 应用貌似不错，为了简化，我们把 todos 存放在内存里。</p>
<p>Koa 是一个极简的框架，它核心里并没有提供 body 解析，session 和 routing。不幸的是 Koa 太嫩了以至于还没有很多 npm 的模块是为它来写的。浏览了一下 <a href="https://github.com/koajs/koa/wiki" target="_blank">Koa 介绍页面</a>发现有一些必要的模块可以供给我们的基本 TODO 应用来使用。</p>
<ol>
<li><a href="https://github.com/koajs/route" target="_blank">koa-route</a>: 用作路由</li>
<li><a href="https://github.com/visionmedia/co-body" target="_blank">co-body</a>: 用作解析 post 请求体</li>
<li><a href="https://github.com/koajs/static" target="_blank">koa-static</a>: 用于处理静态文件</li>
</ol>
<p>下面是基本的服务端 api</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="keyword">var</span> koa          = <span class="built_in">require</span>(<span class="string">'koa'</span>);
<span class="keyword">var</span> staticServer = <span class="built_in">require</span>(<span class="string">'koa-staitc'</span>);

<span class="comment">//这个允许我们解析原生请求对象来获取请求内容</span>
<span class="keyword">var</span> parse        = <span class="built_in">require</span>(<span class="string">'co-body'</span>);

<span class="keyword">var</span> router       = <span class="built_in">require</span>(<span class="string">'koa-route'</span>);
<span class="keyword">var</span> _            = <span class="built_in">require</span>(<span class="string">'underscore'</span>);

<span class="keyword">var</span> Promise      = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);
<span class="keyword">var</span> path         = <span class="built_in">require</span>(<span class="string">'path'</span>);

<span class="keyword">var</span> fs           = Promise.promisifyAll(<span class="built_in">require</span>(<span class="string">'fs'</span>));
<span class="keyword">var</span> app          = koa();

<span class="comment">//我们的最简单的存储方式</span>
<span class="keyword">var</span> todos = [];

<span class="comment">//获取唯一的 id 值</span>
<span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> count = <span class="number">0</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    count++;
    <span class="keyword">return</span> count;
  }
})();

<span class="comment">//处理静态资源文件夹</span>
app.use(staticServer(path.join(__dirname, <span class="string">'public'</span>)));

app.use(router.post(<span class="string">'/todos'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="comment">/*
    yield使我们可以传递异步函数，然后返回内容或者是 promises
    它会冻结当前中间件直到函数被执行完成，然后返回当前中间件继续解冻执行
  */</span>
  <span class="keyword">var</span> todo = (<span class="keyword">yield</span> parse.json(<span class="keyword">this</span>));
  
  todo.id = counter();
  todos.push(todo);
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos);
}));

app.use(router.get(<span class="string">'/todos'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos);
}));

app.use(router.delete(<span class="string">'/todos/:id'</span>, <span class="function"><span class="keyword">function</span> *<span class="params">(id)</span> {</span>
  todos = _(todos).reject(<span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
    console.log(<span class="string">'what? '</span>, todo, id);
    <span class="keyword">return</span> todo.id === <span class="built_in">parseInt</span>(id, <span class="number">10</span>);
  }, <span class="keyword">this</span>);
  <span class="keyword">this</span>.body = <span class="built_in">JSON</span>.stringify(todos.sort(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a - b;
  }));
}));

app.listen(<span class="number">3000</span>);
console.log(<span class="string">'listening on port 3000'</span>);
</pre></td></tr></table></figure>

<p>从 <a href="https://github.com/cultofmetatron/koa-todo" target="_blank">github</a> 上下载完整代码，github 上的版本包含了前端代码。</p>
<h3 id="一些需要注意的：">一些需要注意的：</h3>
<p><code>yield</code> 关键字可以做一些有意思的事情。如果我们向当前中间件传递一个一步函数，这个函数返回数据块或者 promise，那么它会停止执行当前中间件直到函数完成。等它返回数据块或者 promise 后，会恢复生成器执行。这样更容易阅读。</p>
<h3 id="一些警告：">一些警告：</h3>
<p><code>yield</code> 关键字使我们可以写出一些安全的代码块，但它也不总是理想的解决办法。</p>
<p>举个栗子，如果我们执行三个相互不依赖的异步操作，像下面这样…</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">var</span> a = <span class="keyword">yield</span> async1();
  <span class="keyword">var</span> b = <span class="keyword">yield</span> async2();
  <span class="keyword">var</span> c = <span class="keyword">yield</span> async3();
});
</pre></td></tr></table></figure>

<p>这会使 node 的并发失效。当我们调用 async1,我们必须等待 async1 完成才能执行 async2。不过我们可以用 promise 来优化这3个函数，然后生成一个合并的 promise。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span> *<span class="params">()</span> {</span>
  <span class="keyword">var</span> a = async1();
  <span class="keyword">var</span> b = async2();
  <span class="keyword">var</span> c = async3();
  <span class="keyword">var</span> result = <span class="keyword">yield</span> Promise.all([a, b, c]);
});
</pre></td></tr></table></figure>

<blockquote>
<p>注意：tjholowaychuk 大神在原文留言指出了一些问题，见下面图</p>
</blockquote>
<p>当 Koa 框架成熟时，它将会允许更加细粒度的控制以便于我们写出下一代的 web 应用。</p>
<p><img src="/img/koa-zero-to-todo-list-translation/1.png" alt="TJ"></p>
]]></content>
    
    
      <category term="javascript" scheme="http://se77en.cc/tags/javascript/"/>
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="koa" scheme="http://se77en.cc/tags/koa/"/>
    
      <category term="koa" scheme="http://se77en.cc/categories/koa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 迭代器和生成器]]></title>
    <link href="http://se77en.cc/2014/01/20/iterators-and-generators-translation/"/>
    <id>http://se77en.cc/2014/01/20/iterators-and-generators-translation/</id>
    <published>2014-01-20T00:00:00.000Z</published>
    <updated>2014-01-24T01:11:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="迭代器和生成器">迭代器和生成器</h1>
<p>翻译自 MDN 官方文档，原文地址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators?redirectlocale=en-US&amp;redirectslug=JavaScript%2FGuide%2FIterators_and_Generators" target="_blank">Iterators and Generators</a></p>
<p>处理集合里的每一项是一个非常普通的操作，JavaScript提供了许多方法来迭代一个集合，从简单的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for" target="_blank">for</a>和<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a>循环到 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map()</a>，<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter()</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">array comprehensions</a>(数组推导式)。在JavaScript 1.7中，迭代器和生成器在JavaScript核心语法中带来了新的迭代机制，而且还提供了定制 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环行为的机制。</p>
<h2 id="迭代器">迭代器</h2>
<p>迭代器是一个每次访问集合序列中一个元素的对象，并跟踪该序列中迭代的当前位置。在JavaScript中迭代器是一个对象，这个对象提供了一个 <code>next()</code> 方法，<code>next()</code> 方法返回序列中的下一个元素。当序列中所有元素都遍历完成时，该方法抛出 <code>StopIteration</code> 异常。</p>
<p>迭代器对象一旦被建立，就可以通过显式的重复调用<code>next()</code>，或者使用JavaScript的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环隐式调用。</p>
<p>简单的对对象和数组进行迭代的迭代器可以使用 <code>Iterator()</code> 被创建：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>    <span class="keyword">var</span> lang = { name: <span class="string">'JavaScript'</span>, birthYear: <span class="number">1995</span> };
    <span class="keyword">var</span> it = Iterator(lang);
</pre></td></tr></table></figure>

<p>一旦初始化完成，<code>next()</code> 方法可以被调用来依次访问对象的键值对:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"name"</span>, <span class="string">"JavaScript"</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"birthday"</span>, <span class="number">1995</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>一个 `<span class="constant">StopIteration</span>` 异常被抛出
</pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for…in</a> 循环可以被用来替换显式的调用 <code>next()</code> 方法。当 <code>StopIteration</code> 异常被抛出时，循环会自动终止。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次输出 it 中的一个 [key, value] 键值对</span>
</pre></td></tr></table></figure>


<p>如果你只想迭代对象的 key 值，可以往 <code>Iterator()</code> 函数中传入第二个参数，值为 <code>true</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> it)
      print(key); <span class="comment">//每次输出 key 值</span>
</pre></td></tr></table></figure>

<p>使用 <code>Iterator()</code> 访问对象的一个好处是，被添加到 <code>Object.prototype</code> 的自定义属性不会被包含在序列对象中。</p>
<p><code>Iterator()</code> 同样可以被作用在数组上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次迭代输出 [index, language] 键值对</span>
</pre></td></tr></table></figure>

<p>就像遍历对象一样，把 <code>true</code> 当做第二个参数传入遍历的结果将会是数组索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> it)
      print(i); <span class="comment">//输出 0，然后是 1，然后是 2</span>
</pre></td></tr></table></figure>

<p>使用 <code>let</code> 关键字可以在循环内部分别分配索引和值给块变量，还可以解构赋值(Destructuring Assignment)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="reserved">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="reserved">var</span> it = Iterators(langs);
    <span class="keyword">for</span> (<span class="reserved">let</span> [i, lang] <span class="keyword">in</span> it)
      <span class="built_in">print</span>(i + <span class="string">': '</span> + lang); <span class="regexp">//</span>输出 <span class="string">"0: JavaScript"</span> 等
</pre></td></tr></table></figure>

<h2 id="声明自定义迭代器">声明自定义迭代器</h2>
<p>一些代表元素集合的对象应该用一种指定的方式来迭代。</p>
<ul>
<li>迭代一个表示范围(Range)的对象应该一个接一个的返回这个范围包含的数字</li>
<li>一个树的叶子节点可以使用深度优先或者广度优先访问到</li>
<li>迭代一个代表数据库查询结果的对象应该一行一行的返回，即使整个结果集尚未全部加载到一个单一数组</li>
<li>作用在一个无限数学序列(像斐波那契序列)上的迭代器应该在不创建无限长度数据结构的前提下一个接一个的返回结果</li>
</ul>
<p>JavaScript 允许你写自定义迭代逻辑的代码，并把它作用在一个对象上</p>
<p>我们创建一个简单的 <code>Range</code> 对象，包含低和高两个值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
</pre></td></tr></table></figure>

<p>现在我们创建一个自定义迭代器，它返回一个包含范围内所有整数的序列。迭代器接口需要我们提供一个 <code>next()</code> 方法用来返回序列中的下一个元素或者是抛出 <code>StopIteration</code> 异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">RangeIterator</span><span class="params">(range)</span>{</span>
      <span class="keyword">this</span>.range = range;
      <span class="keyword">this</span>.current = <span class="keyword">this</span>.range.low;
    }
    RangeIterator.prototype.next = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.current &gt; <span class="keyword">this</span>.range.high)
        <span class="keyword">throw</span> <span class="built_in">StopIteration</span>;
      <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.current++;
    };
</pre></td></tr></table></figure>

<p>我们的 <code>RangeIterator</code> 通过 range 实例来实例化，同时维持一个 <code>current</code> 属性来跟踪当前序列的位置。</p>
<p>最后，为了让 <code>RangeIterator</code> 可以和 <code>Range</code> 结合起来，我们需要为 <code>Range</code> 添加一个特殊的 <code>__iterator__</code> 方法。当我们试图去迭代一个 <code>Range</code> 时，它将被调用，而且应该返回一个实现了迭代逻辑的 <code>RangeIterator</code> 实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(<span class="keyword">this</span>);
    };
</pre></td></tr></table></figure>

<p>完成我们的自定义迭代器后，我们就可以迭代一个范围实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">range</span> = <span class="built_in">new</span> Range<span class="number">(3</span>,<span class="number"> 5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i in <span class="keyword">range</span>)
      <span class="built_in">print</span>(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<h2 id="生成器：一种更好的方式来构建迭代器">生成器：一种更好的方式来构建迭代器</h2>
<p>虽然自定义的迭代器是一种很有用的工具，但是创建它们的时候要仔细规划，因为需要显式的维护它们的内部状态。<br>生成器提供了很强大的功能：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。</p>
<p>生成器是可以作为迭代器工厂的特殊函数。如果一个函数包含了一个或多个 <code>yield</code> 表达式，那么就称它为生成器(译者注：Node.js 还需要在函数名前加 <code>*</code> 来表示)。</p>
<blockquote>
<p>注意：只有 HTML 中被包含在 <code>&lt;script type=&quot;application/javascript;version=1.7&quot;&gt;</code> (或者更高版本)中的代码块才可以使用 <code>yield</code> 关键字。<a href="https://developer.mozilla.org/en-US/docs/XUL" target="_blank">XUL</a> (XML User Interface Language) 脚本标签不需要指定这个特殊的代码块也可以访问这些特性。</p>
</blockquote>
<p>当一个生成器函数被调用时，函数体不会即刻执行，它会返回一个 generator-iterator 对象。每次调用 generator-iterator 的 <code>next()</code> 方法，函数体就会执行到下一个 <code>yield</code> 表达式，然后返回它的结果。当函数结束或者碰到 <code>return</code> 语句，一个 <code>StopIteration</code> 异常会被抛出。</p>
<p>用一个例子来更好的说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">simpleGenerator</span><span class="params">()</span>{</span>
      <span class="keyword">yield</span> <span class="string">"first"</span>;
      <span class="keyword">yield</span> <span class="string">"second"</span>;
      <span class="keyword">yield</span> <span class="string">"third"</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)
        <span class="keyword">yield</span> i;
    }
    
    <span class="keyword">var</span> g = simpleGenerator();
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "first"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "second"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "third"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 0</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 1</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 2</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//抛出 StopIteration 异常</span>
</pre></td></tr></table></figure>

<p>生成器函数可以被一个类直接的当做 <code>__iterator__</code> 方法使用，在需要自定义迭代器的地方可以有效的减少代码量。我们使用生成器重写一下 <code>Range</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.low; i &lt;= <span class="keyword">this</span>.high; i++)
        <span class="keyword">yield</span> i;
    };
    <span class="keyword">var</span> range = <span class="keyword">new</span> Range(<span class="number">3</span>, <span class="number">5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> range)
      print(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<p>不是所有的生成器都会终止，你可以创建一个代表无限序列的生成器。下面的生成器实现一个斐波那契序列，就是每一个元素都是前面两个的和：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">yield</span> current;
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 2</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 3</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 5</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 8</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 13</span>
</pre></td></tr></table></figure>

<p>生成器函数可以带有参数，并且会在第一次调用函数时使用这些参数。生成器可以被终止(引起它抛出 <code>StopIteration</code> 异常)通过使用 <code>return</code> 语句。下面的 <code>fibonacci()</code> 变体带有一个可选的 limit 参数，当条件被触发时终止函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(limit)</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span>(<span class="number">1</span>){
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">if</span> (limit && current &gt; limit)
          <span class="keyword">return</span>;
        <span class="keyword">yield</span> current;
      }
    }
</pre></td></tr></table></figure>

<h2 id="生成器高级特性">生成器高级特性</h2>
<p>生成器可以根据需求计算yield返回值，这使得它可以表示以前昂贵的序列计算需求，甚至是上面所示的无限序列。</p>
<p>除了 <code>next()</code> 方法，generator-iterator 对象还有一个 <code>send()</code> 方法，该方法可以修改生成器的内部状态。传给 <code>send()</code> 的值将会被当做最后一个 <code>yield</code> 表达式的结果，并且会暂停生成器。在你使用 <code>send()</code> 方法传一个指定值前，你必须至少调用一次 <code>next()</code> 来启动生成器。</p>
<p>下面的斐波那契生成器使用 <code>send()</code> 方法来重启序列：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">var</span> reset = <span class="keyword">yield</span> current;
        <span class="keyword">if</span> (reset) {
          fn1 = <span class="number">1</span>;
          fn2 = <span class="number">1</span>;
        }
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//5</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//8</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//13</span>
    <span class="keyword">print</span>(sequence.send(<span class="keyword">true</span>)); <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
</pre></td></tr></table></figure>

<blockquote>
<p>注意：有意思的一点是，调用 <code>send(undefined)</code> 和调用 <code>next()</code> 是完全同等的。不过，当调用 <code>send()</code> 方法启动一个新的生成器时，除了 <code>undefined</code> 其它的值都会抛出一个 <code>TypeError</code> 异常。</p>
</blockquote>
<p>你可以调用 <code>throw</code> 方法并且传递一个它应该抛出的异常值来强制生成器抛出一个异常。此异常将从当前上下文抛出并暂停生成器，类似当前的 <code>yield</code> 执行，只不过换成了 <code>throw value</code> 语句。</p>
<p>如果在抛出异常的处理过程中没有遇到 <code>yield</code> ，该异常将会被传递直到调用 <code>throw()</code> 方法，并且随后调用 <code>next()</code> 将会导致 <code>StopIteration</code> 异常被抛出。</p>
<p>生成器拥有一个 <code>close()</code> 方法来强制生成器结束。结束一个生成器会产生如下影响：</p>
<ol>
<li>所有生成器中有效的 <code>finally</code> 字句将会执行</li>
<li>如果 <code>finally</code> 字句抛出了除 <code>StopIteration</code> 以外的任何异常，该异常将会被传递到 <code>close()</code> 方法的调用者</li>
<li>生成器会终止</li>
</ol>
<h2 id="生成器表达式">生成器表达式</h2>
<p><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">数组推导式</a>的一个明显缺点是，它们会导致整个数组在内存中构造。当输入到推导式的本身是个小数组时它的开销是微不足道的—但是，当输入数组很大或者创建一个新的昂贵(或者是无限的)数组生成器时就可能出现问题。</p>
<p>生成器允许对序列延迟计算(lazy computation)，在需要时按需计算元素。生成器表达式在句法上几乎和数组推导式相同—它用圆括号来代替方括号(而且用 <code>for...in</code> 代替 <code>for each...in</code>)—但是它创建一个生成器而不是数组，这样就可以延迟计算。你可以把它想象成创建生成器的简短语法。</p>
<p>假设我们有一个迭代器 <code>it</code> 来迭代一个巨大的整数序列。我们需要创建一个新的迭代器来迭代偶数。一个数组推导式将会在内存中创建整个包含所有偶数的数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> doubles = [i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it)];
</pre></td></tr></table></figure>

<p>而生成器表达式将会创建一个新的迭代器，并且在需要的时候按需来计算偶数值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var it2 = (i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//it</span> 里面的第一个偶数
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//it</span> 里面的第二个偶数
</pre></td></tr></table></figure>

<p>当一个生成器被用做函数的参数，圆括号被用做函数调用，意味着最外层的圆括号可以被省略：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">result</span> = doSomething(i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
</pre></td></tr></table></figure>

<hr>
<p><a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a> 主题已华丽更新，再次推荐！</p>
]]></content>
    
    
      <category term="javascript" scheme="http://se77en.cc/tags/javascript/"/>
    
      <category term="iterator" scheme="http://se77en.cc/tags/iterator/"/>
    
      <category term="generator" scheme="http://se77en.cc/tags/generator/"/>
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="javascript" scheme="http://se77en.cc/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[告别node-forever,拥抱PM2]]></title>
    <link href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/"/>
    <id>http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/</id>
    <published>2013-06-27T06:43:36.000Z</published>
    <updated>2014-02-05T09:34:08.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址:<a href="http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Goodbye node-forever,hello PM2</a></p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm22.png" alt="pm2-logo"></p>
<p>devo.ps团队对JavaScript的迷恋已经不是什么秘密了;node.js作为服务器端,AngularJS作为客户端,某种程度上说,我们的堆栈是用它建成的.我们构建<a href="http://devo.ps/blog/2013/01/31/farewell-to-regular-web-development-approaches.html" target="_blank">静态客户端和RESTful JSON API</a>的方法意味着我们跑了很多的node.js,我必须承认尽管node.js的一切都令人敬畏,但当我们在生产环境中运行它时它仍然会让我们感到头疼.相比一些更加成熟的语言,它的工具和最佳实践仍然缺乏(试想一下:监控,日志,错误处理).</p>
<p>到目前为止,我们仍然依赖漂亮俏皮的<a href="https://github.com/nodejitsu/forever" target="_blank">node-forever模块</a>.它是非常伟大的模块,不过依然缺失一些功能:</p>
<ul>
<li>有限的监控和日志功能</li>
<li>进程管理配置的支持差</li>
<li>不支持集群</li>
<li>代码库老化(意味着在升级node.js时频繁的失败)</li>
</ul>
<p>这就是为什么我们要在过去的几个月里去写<a href="https://github.com/Unitech/pm2" target="_blank">PM2模块</a>.在我们即将发布针对生产环境的正式版之前我们想先让您看一眼.</p>
<h3 id="<strong>PM2到底是什么个东西呢?</strong>"><strong>PM2到底是什么个东西呢?</strong></h3>
<p>首先第一件事,你需要先通过<code>npm</code>来安装它:</p>
<pre><code>npm <span class="keyword">install</span> -g pm2
</code></pre><p>让我们通过表格来对比下:</p>
<table class="table table-bordered table-striped table-condensed"><br>   <tr><br>      <th width="50%">Feature</th><br>      <th width="25%">Forever</th><br>      <th width="25%">PM2</th><br>   </tr><br>   <tr><br>      <td>Keep Alive</td><br>      <td>&#10004;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Coffeescript</td><br>      <td>&#10004;</td><br>      <td>&nbsp;</td><br>   </tr><br>   <tr><br>      <td>Log aggregation</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>API</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Terminal monitoring</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>Clustering</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br>   <tr><br>      <td>JSON configuration</td><br>      <td>&nbsp;</td><br>      <td>&#10004;</td><br>   </tr><br></table>


<p>现在让我来介绍一点点主要特性…</p>
<h3 id="<strong>原生的集群化支持</strong>"><strong>原生的集群化支持</strong></h3>
<p>Node v0.6引入了集群特性,允许你在多个Node应用中共享socket.问题在于,它不能在容器外运行而且需要一些额外的配置来处理主进程和子进程.</p>
<p>PM2原生支持处理这个问题,而且不需要额外的代码:PM2本身作为主进程,然后它将你的代码封装到一个特殊的集群进程里,就像node.js一样,为你的代码文件添加一些全局变量.</p>
<p>想要启动一个使用所有CPU核心的集群,你只需要键入如下的指令:</p>
<pre><code>$ pm2 <span class="operator"><span class="keyword">start</span> app.js -i <span class="aggregate">max</span></span>
</code></pre><p>然后:</p>
<pre><code><span class="variable">$ </span>pm2 list
</code></pre><p>然后就会显示类似下面的东西(ASCII UI FTW);</p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-list.png" alt="pm2-list"></p>
<p>就像你看到的,现在你的应用有多少个进程就取决于你的CPU核心数了</p>
<h3 id="<strong>按照termcaps-HTOP(Linux下的系统监控与进程管理软件)的方式管理</strong>"><strong>按照termcaps-HTOP(Linux下的系统监控与进程管理软件)的方式管理</strong></h3>
<p>通过<code>pm2 list</code>命令来观察所有运行的进程以及它们的状态已经足够好了.但是怎么来追踪它们的资源消耗呢?别担心,用这个命令:</p>
<pre><code><span class="variable">$ </span>pm2 monit
</code></pre><p>你可以得到进程(以及集群)的CPU的使用率和内存占用.</p>
<p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-monit.png" alt="pm2-monit"></p>
<p><strong>声明:</strong><a href="https://github.com/arunoda/node-usage" target="_blank">node-usage</a>到目前为止还不支持MacOS(随便什么性能要求),不过它在Linux下运行良好.</p>
<p>现在,让我们来核实一下我们的集群,还有对内存堆栈的垃圾回收,我们假设你已经有一个HTTP基准测试工具(如果没有,你一定要使用<a href="https://github.com/wg/wrk" target="_blank">WRK</a>):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    $ express bufallo    <span class="comment">//Create an express app</span>
    $ cd bufallo
    $ npm install
    $ pm2 start app<span class="built_in">.</span>js <span class="attribute">-i</span> <span class="keyword">max</span>
    $ wrk <span class="attribute">-c</span> <span class="number">100</span> <span class="attribute">-d</span> <span class="number">100</span> http:<span class="comment">//localhost:3000/</span>
</pre></td></tr></table></figure>

<p>在另一个终端,运行监控选项:</p>
<pre><code><span class="variable">$ </span>pm2 monit
</code></pre><p>耶~</p>
<h3 id="<strong>实时集中log处理</strong>"><strong>实时集中log处理</strong></h3>
<p>现在你不得不管理多个集群进程:一个爬取数据,一个处理数据,等等…这就意味着大量log,你可以按照老式的方法处理:</p>
<pre><code>$ tail -f /path/to/log1 /path/to/log2 <span class="keyword">...</span>
</code></pre><p>但我们想的很周到,我们增加了<code>logs</code>功能:</p>
<pre><code><span class="variable">$ </span>pm2 logs
</code></pre><p><img src="/img/goodbye-node-forever-hello-pm2-translation/pm2-logs.png" alt="pm2-logs"></p>
<h3 id="<strong>快速恢复</strong>"><strong>快速恢复</strong></h3>
<p>现在事情一切顺利,你的进程嗡嗡的运行着,你需要做一次硬重启(hard restart).现在吗?是的,首先,dump掉:</p>
<pre><code><span class="variable">$ </span>pm2 dump
</code></pre><p>然后,你可以从文件中恢复它:</p>
<pre><code>$ pm2 <span class="built_in">kill</span>     <span class="comment"> //让我们假设一个PM2停掉了</span>
$ pm2 resurect <span class="comment"> //我所有的进程又满血满状态复活了</span>
</code></pre><h3 id="<strong>强健的API</strong>"><strong>强健的API</strong></h3>
<p>比方说,你想要监控所有被PM2管理的进程,而且同时还想监控运行这些进程的机器的状态(甚至希望创建一个Angular应用来调用这些API…):</p>
<pre><code><span class="variable">$ </span>pm2 web
</code></pre><p>打开浏览器输入<a href="http://localhost:9615" target="_blank">http://localhost:9615</a> ,我嘞个去!</p>
<h3 id="<strong>对了,还有很多特性…</strong>"><strong>对了,还有很多特性…</strong></h3>
<ul>
<li>全部测试通过,</li>
<li>新一代的<code>update-rc.d</code>(<code>pm2 startup</code>),当然它还是alpha版,</li>
<li>开发模式下更改文件自动重启(<code>pm2 dev</code>),也同样还是草稿,</li>
<li>自动刷新log,</li>
<li>快捷的通过JSON文件管理你的应用,</li>
<li>在error log里记录未捕获的异常,</li>
<li>记录重启的次数和时间,</li>
<li>退出时自动杀死进程.</li>
</ul>
<h2 id="<strong>下一步计划?</strong>"><strong>下一步计划?</strong></h2>
<p>首先,你可以去<a href="https://github.com/Unitech/pm2" target="_blank">Github上</a>粉我们(我们喜欢stars).</p>
<p>我们开发的PM2提供了先进完整的Node进程管理解决方案.我们希望能有更多的人来帮助我们:更多的pull requests.一些还停留在开发路线图上面的功能我们会尽快完成,下面这些就是:</p>
<ul>
<li>远程管理/状态校验,</li>
<li>嵌入式跨进程通信通道(消息总线),</li>
<li>V8垃圾回收的内存泄漏检查,</li>
<li>Web界面,</li>
<li>监控数据持久化,</li>
<li>邮件通知.</li>
</ul>
<p>特别感谢<a href="https://github.com/makara" target="_blank">Makara Wang</a>的观点和工具,还有<a href="https://github.com/rlidwka" target="_blank">Alex Kocharin</a>提的建议和提交的代码.</p>
<ul>
<li>在<a href="https://twitter.com/intent/tweet?text=@devo_ps%20&amp;related=devo_ps&amp;url=http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Twitter</a>上给我们反馈吧.</li>
<li>欢迎在<a href="http://news.ycombinator.com/item?id=5945420" target="_blank">Hacker News</a>上和我们一起谈论</li>
</ul>
<p>本博客基于<a href="http://zespia.tw/hexo/zh-CN/" target="_blank">hexo</a>搭建,推荐一个不错的主题<a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a>,虽然我还没用上,不过可以去<a href="http://yangjian.me" target="_blank">@A-limon</a>的主页查看效果.</p>
<p>最后感谢<a href="http://weibo.com/436062867" target="_blank">@A-limon</a>同学提供翻译建议和审读.</p>
]]></content>
    
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="PM2" scheme="http://se77en.cc/tags/PM2/"/>
    
      <category term="node.js" scheme="http://se77en.cc/categories/node.js/"/>
    
  </entry>
  
</feed>
