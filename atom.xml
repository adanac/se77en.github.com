<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AriesDevil's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://se77en.cc/"/>
  <updated>2014-01-21T01:23:56.548Z</updated>
  <id>http://se77en.cc/</id>
  
  <author>
    <name><![CDATA[Damon Zhao]]></name>
    <email><![CDATA[se77en.cc@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 迭代器和生成器]]></title>
    <link href="http://se77en.cc/2014/01/20/iterators-and-generators-translation/"/>
    <id>http://se77en.cc/2014/01/20/iterators-and-generators-translation/</id>
    <published>2014-01-20T12:14:04.000Z</published>
    <updated>2014-01-20T12:14:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="-">迭代器和生成器</h1>
<p>翻译自 MDN 官方文档，原文地址：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators?redirectlocale=en-US&amp;redirectslug=JavaScript%2FGuide%2FIterators_and_Generators" target="_blank">Iterators and Generators</a></p>
<p>处理集合里的每一项是一个非常普通的操作，JavaScript提供了许多方法来迭代一个集合，从简单的<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for" target="_blank">for</a>和<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a>循环到 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map" target="_blank">map()</a>，<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter" target="_blank">filter()</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">array comprehensions</a>(数组推导式)。在JavaScript 1.7中，迭代器和生成器在JavaScript核心语法中带来了新的迭代机制，而且还提供了定制 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for...in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环行为的机制。</p>
<h2 id="-">迭代器</h2>
<p>迭代器是一个每次访问集合序列中一个元素的对象，并跟踪该序列中迭代的当前位置。在JavaScript中迭代器是一个对象，这个对象提供了一个 <code>next()</code> 方法，<code>next()</code> 方法返回序列中的下一个元素。当序列中所有元素都遍历完成时，该方法抛出 <code>StopIteration</code> 异常。</p>
<p>迭代器对象一旦被建立，就可以通过显式的重复调用<code>next()</code>，或者使用JavaScript的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for...in</a> 和 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for_each...in" target="_blank">for each</a> 循环隐式调用。</p>
<p>简单的对对象和数组进行迭代的迭代器可以使用 <code>Iterator()</code> 被创建：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>    <span class="keyword">var</span> lang = { name: <span class="string">'JavaScript'</span>, birthYear: <span class="number">1995</span> };
    <span class="keyword">var</span> it = Iterator(lang);
</pre></td></tr></table></figure>

<p>一旦初始化完成，<code>next()</code> 方法可以被调用来依次访问对象的键值对:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"name"</span>, <span class="string">"JavaScript"</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>键值对是[<span class="string">"birthday"</span>, <span class="number">1995</span>]
    pair = it.<span class="keyword">next</span>(); <span class="regexp">//</span>一个 `<span class="constant">StopIteration</span>` 异常被抛出
</pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in" target="_blank">for...in</a> 循环可以被用来替换显式的调用 <code>next()</code> 方法。当 <code>StopIteration</code> 异常被抛出时，循环会自动终止。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次输出 it 中的一个 [key, value] 键值对</span>
</pre></td></tr></table></figure>


<p>如果你只想迭代对象的 key 值，可以往 <code>Iterator()</code> 函数中传入第二个参数，值为 <code>true</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(lang, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> it)
      print(key); <span class="comment">//每次输出 key 值</span>
</pre></td></tr></table></figure>

<p>使用 <code>Iterator()</code> 访问对象的一个好处是，被添加到 <code>Object.prototype</code> 的自定义属性不会被包含在序列对象中。</p>
<p><code>Iterator()</code> 同样可以被作用在数组上：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs);
    <span class="keyword">for</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> it)
      print(pair); <span class="comment">//每次迭代输出 [index, language] 键值对</span>
</pre></td></tr></table></figure>

<p>就像遍历对象一样，把 <code>true</code> 当做第二个参数传入遍历的结果将会是数组索引：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="keyword">var</span> it = <span class="keyword">Iterator</span>(langs, <span class="keyword">true</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> it)
      print(i); <span class="comment">//输出 0，然后是 1，然后是 2</span>
</pre></td></tr></table></figure>

<p>使用 <code>let</code> 关键字可以在循环内部分别分配索引和值给块变量，还可以解构赋值(Destructuring Assignment)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="reserved">var</span> langs = [<span class="string">'JavaScript'</span>, <span class="string">'Python'</span>, <span class="string">'Haskell'</span>];
    <span class="reserved">var</span> it = Iterators(langs);
    <span class="keyword">for</span> (<span class="reserved">let</span> [i, lang] <span class="keyword">in</span> it)
      <span class="built_in">print</span>(i + <span class="string">': '</span> + lang); <span class="regexp">//</span>输出 <span class="string">"0: JavaScript"</span> 等
</pre></td></tr></table></figure>

<h2 id="-">声明自定义迭代器</h2>
<p>一些代表元素集合的对象应该用一种指定的方式来迭代。</p>
<ul>
<li>迭代一个表示范围(Range)的对象应该一个接一个的返回这个范围包含的数字</li>
<li>一个树的叶子节点可以使用深度优先或者广度优先访问到</li>
<li>迭代一个代表数据库查询结果的对象应该一行一行的返回，即使整个结果集尚未全部加载到一个单一数组</li>
<li>作用在一个无限数学序列(像斐波那契序列)上的迭代器应该在不创建无限长度数据结构的前提下一个接一个的返回结果</li>
</ul>
<p>JavaScript 允许你写自定义迭代逻辑的代码，并把它作用在一个对象上</p>
<p>我们创建一个简单的 <code>Range</code> 对象，包含低和高两个值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
</pre></td></tr></table></figure>

<p>现在我们创建一个自定义迭代器，它返回一个包含范围内所有整数的序列。迭代器接口需要我们提供一个 <code>next()</code> 方法用来返回序列中的下一个元素或者是抛出 <code>StopIteration</code> 异常。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">RangeIterator</span><span class="params">(range)</span>{</span>
      <span class="keyword">this</span>.range = range;
      <span class="keyword">this</span>.current = <span class="keyword">this</span>.range.low;
    }
    RangeIterator.prototype.next = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.current &gt; <span class="keyword">this</span>.range.high)
        <span class="keyword">throw</span> <span class="built_in">StopIteration</span>;
      <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.current++;
    };
</pre></td></tr></table></figure>

<p>我们的 <code>RangeIterator</code> 通过 range 实例来实例化，同时维持一个 <code>current</code> 属性来跟踪当前序列的位置。</p>
<p>最后，为了让 <code>RangeIterator</code> 可以和 <code>Range</code> 结合起来，我们需要为 <code>Range</code> 添加一个特殊的 <code>__iterator__</code> 方法。当我们试图去迭代一个 <code>Range</code> 时，它将被调用，而且应该返回一个实现了迭代逻辑的 <code>RangeIterator</code> 实例。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(<span class="keyword">this</span>);
    };
</pre></td></tr></table></figure>

<p>完成我们的自定义迭代器后，我们就可以迭代一个范围实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">range</span> = <span class="built_in">new</span> Range<span class="number">(3</span>,<span class="number"> 5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i in <span class="keyword">range</span>)
      <span class="built_in">print</span>(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<h2 id="-">生成器：一种更好的方式来构建迭代器</h2>
<p>虽然自定义的迭代器是一种很有用的工具，但是创建它们的时候要仔细规划，因为需要显式的维护它们的内部状态。
生成器提供了很强大的功能：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。</p>
<p>生成器是可以作为迭代器工厂的特殊函数。如果一个函数包含了一个或多个 <code>yield</code> 表达式，那么就称它为生成器(译者注：Node.js 还需要在函数名前加 <code>*</code> 来表示)。</p>
<blockquote>
<p>注意：只有 HTML 中被包含在 <code>&lt;script type=&quot;application/javascript;version=1.7&quot;&gt;</code> (或者更高版本)中的代码块才可以使用 <code>yield</code> 关键字。<a href="https://developer.mozilla.org/en-US/docs/XUL" target="_blank">XUL</a> (XML User Interface Language) 脚本标签不需要指定这个特殊的代码块也可以访问这些特性。</p>
</blockquote>
<p>当一个生成器函数被调用时，函数体不会即刻执行，它会返回一个 generator-iterator 对象。每次调用 generator-iterator 的 <code>next()</code> 方法，函数体就会执行到下一个 <code>yield</code> 表达式，然后返回它的结果。当函数结束或者碰到 <code>return</code> 语句，一个 <code>StopIteration</code> 异常会被抛出。</p>
<p>用一个例子来更好的说明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">simpleGenerator</span><span class="params">()</span>{</span>
      <span class="keyword">yield</span> <span class="string">"first"</span>;
      <span class="keyword">yield</span> <span class="string">"second"</span>;
      <span class="keyword">yield</span> <span class="string">"third"</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)
        <span class="keyword">yield</span> i;
    }
    
    <span class="keyword">var</span> g = simpleGenerator();
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "first"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "second"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 "third"</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 0</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 1</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//输出 2</span>
    <span class="keyword">print</span>(g.next()); <span class="comment">//抛出 StopIteration 异常</span>
</pre></td></tr></table></figure>

<p>生成器函数可以被一个类直接的当做 <code>__iterator__</code> 方法使用，在需要自定义迭代器的地方可以有效的减少代码量。我们使用生成器重写一下 <code>Range</code> ：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(low, high)</span>{</span>
      <span class="keyword">this</span>.low = low;
      <span class="keyword">this</span>.high = high;
    }
    Range.prototype.__iterator__ = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.low; i &lt;= <span class="keyword">this</span>.high; i++)
        <span class="keyword">yield</span> i;
    };
    <span class="keyword">var</span> range = <span class="keyword">new</span> Range(<span class="number">3</span>, <span class="number">5</span>);
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> range)
      print(i); <span class="comment">//输出 3，然后 4，然后 5</span>
</pre></td></tr></table></figure>

<p>不是所有的生成器都会终止，你可以创建一个代表无限序列的生成器。下面的生成器实现一个斐波那契序列，就是每一个元素都是前面两个的和：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">yield</span> current;
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 1</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 2</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 3</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 5</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 8</span>
    <span class="keyword">print</span>(sequence.next()); <span class="comment">// 13</span>
</pre></td></tr></table></figure>

<p>生成器函数可以带有参数，并且会在第一次调用函数时使用这些参数。生成器可以被终止(引起它抛出 <code>StopIteration</code> 异常)通过使用 <code>return</code> 语句。下面的 <code>fibonacci()</code> 变体带有一个可选的 limit 参数，当条件被触发时终止函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(limit)</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span>(<span class="number">1</span>){
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">if</span> (limit && current &gt; limit)
          <span class="keyword">return</span>;
        <span class="keyword">yield</span> current;
      }
    }
</pre></td></tr></table></figure>

<h2 id="-">生成器高级特性</h2>
<p>生成器可以根据需求计算yield返回值，这使得它可以表示以前昂贵的序列计算需求，甚至是上面所示的无限序列。</p>
<p>除了 <code>next()</code> 方法，generator-iterator 对象还有一个 <code>send()</code> 方法，该方法可以修改生成器的内部状态。传给 <code>send()</code> 的值将会被当做最后一个 <code>yield</code> 表达式的结果，并且会暂停生成器。在你使用 <code>send()</code> 方法传一个指定值前，你必须至少调用一次 <code>next()</code> 来启动生成器。</p>
<p>下面的斐波那契生成器使用 <code>send()</code> 方法来重启序列：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">()</span>{</span>
      <span class="keyword">var</span> fn1 = <span class="number">1</span>;
      <span class="keyword">var</span> fn2 = <span class="number">1</span>;
      <span class="keyword">while</span> (<span class="number">1</span>) {
        <span class="keyword">var</span> current = fn2;
        fn2 = fn1;
        fn1 = fn1 + current;
        <span class="keyword">var</span> reset = <span class="keyword">yield</span> current;
        <span class="keyword">if</span> (reset) {
          fn1 = <span class="number">1</span>;
          fn2 = <span class="number">1</span>;
        }
      }
    }
    
    <span class="keyword">var</span> sequence = fibonacci();
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//5</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//8</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//13</span>
    <span class="keyword">print</span>(sequence.send(<span class="keyword">true</span>)); <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//1</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//2</span>
    <span class="keyword">print</span>(sequence.next());     <span class="comment">//3</span>
</pre></td></tr></table></figure>

<blockquote>
<p>注意：有意思的一点是，调用 <code>send(undefined)</code> 和调用 <code>next()</code> 是完全同等的。不过，当调用 <code>send()</code> 方法启动一个新的生成器时，除了 <code>undefined</code> 其它的值都会抛出一个 <code>TypeError</code> 异常。</p>
</blockquote>
<p>你可以调用 <code>throw</code> 方法并且传递一个它应该抛出的异常值来强制生成器抛出一个异常。此异常将从当前上下文抛出并暂停生成器，类似当前的 <code>yield</code> 执行，只不过换成了 <code>throw value</code> 语句。</p>
<p>如果在抛出异常的处理过程中没有遇到 <code>yield</code> ，该异常将会被传递直到调用 <code>throw()</code> 方法，并且随后调用 <code>next()</code> 将会导致 <code>StopIteration</code> 异常被抛出。</p>
<p>生成器拥有一个 <code>close()</code> 方法来强制生成器结束。结束一个生成器会产生如下影响：</p>
<ol>
<li>所有生成器中有效的 <code>finally</code> 字句将会执行</li>
<li>如果 <code>finally</code> 字句抛出了除 <code>StopIteration</code> 以外的任何异常，该异常将会被传递到 <code>close()</code> 方法的调用者</li>
<li>生成器会终止</li>
</ol>
<h2 id="-">生成器表达式</h2>
<p><a href="https://developer.mozilla.org/en/JavaScript/Guide/Predefined_Core_Objects#Array_comprehensions" target="_blank">数组推导式</a>的一个明显缺点是，它们会导致整个数组在内存中构造。当输入到推导式的本身是个小数组时它的开销是微不足道的--但是，当输入数组很大或者创建一个新的昂贵(或者是无限的)数组生成器时就可能出现问题。</p>
<p>生成器允许对序列延迟计算(lazy computation)，在需要时按需计算元素。生成器表达式在句法上几乎和数组推导式相同--它用圆括号来代替方括号(而且用 <code>for...in</code> 代替 <code>for each...in</code>)--但是它创建一个生成器而不是数组，这样就可以延迟计算。你可以把它想象成创建生成器的简短语法。</p>
<p>假设我们有一个迭代器 <code>it</code> 来迭代一个巨大的整数序列。我们需要创建一个新的迭代器来迭代偶数。一个数组推导式将会在内存中创建整个包含所有偶数的数组：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> doubles = [i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it)];
</pre></td></tr></table></figure>

<p>而生成器表达式将会创建一个新的迭代器，并且在需要的时候按需来计算偶数值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    var it2 = (i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//</span>第一个 it 里面的偶数
    print(it2.<span class="keyword">next</span>());  <span class="regexp">//</span>第二个 it 里面的偶数
</pre></td></tr></table></figure>

<p>当一个生成器被用做函数的参数，圆括号被用做函数调用，意味着最外层的圆括号可以被省略：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="keyword">var</span> <span class="keyword">result</span> = doSomething(i * <span class="number">2</span> <span class="keyword">for</span> (i <span class="keyword">in</span> it));
</pre></td></tr></table></figure>

<hr>
<p><a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a> 主题已华丽更新，再次推荐！</p>
]]></content>
    
    
      <category term="javascript" scheme="http://se77en.cc/tags/javascript/"/>
    
      <category term="iterator" scheme="http://se77en.cc/tags/iterator/"/>
    
      <category term="generator" scheme="http://se77en.cc/tags/generator/"/>
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="javascript" scheme="http://se77en.cc/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[告别node-forever,拥抱PM2]]></title>
    <link href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/"/>
    <id>http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/</id>
    <published>2013-06-27T06:43:36.000Z</published>
    <updated>2014-01-20T08:36:04.000Z</updated>
    <content type="html"><![CDATA[<p>原文地址:<a href="http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Goodbye node-forever,hello PM2</a></p>
<p><img src="/img/pm22.png" alt="pm2-logo"></p>
<p>devo.ps团队对JavaScript的迷恋已经不是什么秘密了;node.js作为服务器端,AngularJS作为客户端,某种程度上说,我们的堆栈是用它建成的.我们构建<a href="http://devo.ps/blog/2013/01/31/farewell-to-regular-web-development-approaches.html" target="_blank">静态客户端和RESTful JSON API</a>的方法意味着我们跑了很多的node.js,我必须承认尽管node.js的一切都令人敬畏,但当我们在生产环境中运行它时它仍然会让我们感到头疼.相比一些更加成熟的语言,它的工具和最佳实践仍然缺乏(试想一下:监控,日志,错误处理).</p>
<p>到目前为止,我们仍然依赖漂亮俏皮的<a href="https://github.com/nodejitsu/forever" target="_blank">node-forever模块</a>.它是非常伟大的模块,不过依然缺失一些功能:</p>
<ul>
<li>有限的监控和日志功能</li>
<li>进程管理配置的支持差</li>
<li>不支持集群</li>
<li>代码库老化(意味着在升级node.js时频繁的失败)</li>
</ul>
<p>这就是为什么我们要在过去的几个月里去写<a href="https://github.com/Unitech/pm2" target="_blank">PM2模块</a>.在我们即将发布针对生产环境的正式版之前我们想先让您看一眼.</p>
<h3 id="-pm2-"><strong>PM2到底是什么个东西呢?</strong></h3>
<p>首先第一件事,你需要先通过<code>npm</code>来安装它:</p>
<pre><code>npm install -g pm2
</code></pre><p>让我们通过表格来对比下:</p>
<table class="table table-bordered table-striped table-condensed">
   <tr>
      <th width="50%">Feature</th>
      <th width="25%">Forever</th>
      <th width="25%">PM2</th>
   </tr>
   <tr>
      <td>Keep Alive</td>
      <td>&#10004;</td>
      <td>&#10004;</td>
   </tr>
   <tr>
      <td>Coffeescript</td>
      <td>&#10004;</td>
      <td>&nbsp;</td>
   </tr>
   <tr>
      <td>Log aggregation</td>
      <td>&nbsp;</td>
      <td>&#10004;</td>
   </tr>
   <tr>
      <td>API</td>
      <td>&nbsp;</td>
      <td>&#10004;</td>
   </tr>
   <tr>
      <td>Terminal monitoring</td>
      <td>&nbsp;</td>
      <td>&#10004;</td>
   </tr>
   <tr>
      <td>Clustering</td>
      <td>&nbsp;</td>
      <td>&#10004;</td>
   </tr>
   <tr>
      <td>JSON configuration</td>
      <td>&nbsp;</td>
      <td>&#10004;</td>
   </tr>
</table>


<p>现在让我来介绍一点点主要特性...</p>
<h3 id="-"><strong>原生的集群化支持</strong></h3>
<p>Node v0.6引入了集群特性,允许你在多个Node应用中共享socket.问题在于,它不能在容器外运行而且需要一些额外的配置来处理主进程和子进程.</p>
<p>PM2原生支持处理这个问题,而且不需要额外的代码:PM2本身作为主进程,然后它将你的代码封装到一个特殊的集群进程里,就像node.js一样,为你的代码文件添加一些全局变量.</p>
<p>想要启动一个使用所有CPU核心的集群,你只需要键入如下的指令:</p>
<pre><code>$ pm2 start app.js -i max
</code></pre><p>然后:</p>
<pre><code>$ pm2 list
</code></pre><p>然后就会显示类似下面的东西(ASCII UI FTW);</p>
<p><img src="/img/pm2-list.png" alt="pm2-list"></p>
<p>就像你看到的,现在你的应用有多少个进程就取决于你的CPU核心数了</p>
<h3 id="-termcaps-htop-linux-"><strong>按照termcaps-HTOP(Linux下的系统监控与进程管理软件)的方式管理</strong></h3>
<p>通过<code>pm2 list</code>命令来观察所有运行的进程以及它们的状态已经足够好了.但是怎么来追踪它们的资源消耗呢?别担心,用这个命令:</p>
<pre><code>$ pm2 monit
</code></pre><p>你可以得到进程(以及集群)的CPU的使用率和内存占用.</p>
<p><img src="/img/pm2-monit.png" alt="pm2-monit"></p>
<p><strong>声明:</strong><a href="https://github.com/arunoda/node-usage" target="_blank">node-usage</a>到目前为止还不支持MacOS(随便什么性能要求),不过它在Linux下运行良好.</p>
<p>现在,让我们来核实一下我们的集群,还有对内存堆栈的垃圾回收,我们假设你已经有一个HTTP基准测试工具(如果没有,你一定要使用<a href="https://github.com/wg/wrk" target="_blank">WRK</a>):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    $ express bufallo    <span class="comment">//Create an express app</span>
    $ cd bufallo
    $ npm install
    $ pm2 start app<span class="built_in">.</span>js <span class="attribute">-i</span> <span class="keyword">max</span>
    $ wrk <span class="attribute">-c</span> <span class="number">100</span> <span class="attribute">-d</span> <span class="number">100</span> http:<span class="comment">//localhost:3000/</span>
</pre></td></tr></table></figure>

<p>在另一个终端,运行监控选项:</p>
<pre><code>$ pm2 monit
</code></pre><p>耶~</p>
<h3 id="-log-"><strong>实时集中log处理</strong></h3>
<p>现在你不得不管理多个集群进程:一个爬取数据,一个处理数据,等等...这就意味着大量log,你可以按照老式的方法处理:</p>
<pre><code>$ tail -f /path/to/log1 /path/to/log2 ...
</code></pre><p>但我们想的很周到,我们增加了<code>logs</code>功能:</p>
<pre><code>$ pm2 logs
</code></pre><p><img src="/img/pm2-logs.png" alt="pm2-logs"></p>
<h3 id="-"><strong>快速恢复</strong></h3>
<p>现在事情一切顺利,你的进程嗡嗡的运行着,你需要做一次硬重启(hard restart).现在吗?是的,首先,dump掉:</p>
<pre><code>$ pm2 dump
</code></pre><p>然后,你可以从文件中恢复它:</p>
<pre><code>$ pm2 kill      //让我们假设一个PM2停掉了
$ pm2 resurect  //我所有的进程又满血满状态复活了
</code></pre><h3 id="-api-"><strong>强健的API</strong></h3>
<p>比方说,你想要监控所有被PM2管理的进程,而且同时还想监控运行这些进程的机器的状态(甚至希望创建一个Angular应用来调用这些API...):</p>
<pre><code>$ pm2 web
</code></pre><p>打开浏览器输入<a href="http://localhost:9615" target="_blank"><a href="http://localhost:9615">http://localhost:9615</a></a> ,我嘞个去!</p>
<h3 id="-"><strong>对了,还有很多特性...</strong></h3>
<ul>
<li>全部测试通过,</li>
<li>新一代的<code>update-rc.d</code>(<code>pm2 startup</code>),当然它还是alpha版,</li>
<li>开发模式下更改文件自动重启(<code>pm2 dev</code>),也同样还是草稿,</li>
<li>自动刷新log,</li>
<li>快捷的通过JSON文件管理你的应用,</li>
<li>在error log里记录未捕获的异常,</li>
<li>记录重启的次数和时间,</li>
<li>退出时自动杀死进程.</li>
</ul>
<h2 id="-"><strong>下一步计划?</strong></h2>
<p>首先,你可以去<a href="https://github.com/Unitech/pm2" target="_blank">Github上</a>粉我们(我们喜欢stars).</p>
<p>我们开发的PM2提供了先进完整的Node进程管理解决方案.我们希望能有更多的人来帮助我们:更多的pull requests.一些还停留在开发路线图上面的功能我们会尽快完成,下面这些就是:</p>
<ul>
<li>远程管理/状态校验,</li>
<li>嵌入式跨进程通信通道(消息总线),</li>
<li>V8垃圾回收的内存泄漏检查,</li>
<li>Web界面,</li>
<li>监控数据持久化,</li>
<li>邮件通知.</li>
</ul>
<p>特别感谢<a href="https://github.com/makara" target="_blank">Makara Wang</a>的观点和工具,还有<a href="https://github.com/rlidwka" target="_blank">Alex Kocharin</a>提的建议和提交的代码.</p>
<ul>
<li>在<a href="https://twitter.com/intent/tweet?text=@devo_ps%20&amp;related=devo_ps&amp;url=http://devo.ps/blog/2013/06/26/goodbye-node-forever-hello-pm2.html" target="_blank">Twitter</a>上给我们反馈吧.</li>
<li>欢迎在<a href="http://news.ycombinator.com/item?id=5945420" target="_blank">Hacker News</a>上和我们一起谈论</li>
</ul>
<p>本博客基于<a href="http://zespia.tw/hexo/zh-CN/" target="_blank">hexo</a>搭建,推荐一个不错的主题<a href="https://github.com/A-limon/pacman" target="_blank">Pacman</a>,虽然我还没用上,不过可以去<a href="http://yangjian.me" target="_blank">@A-limon</a>的主页查看效果.</p>
<p>最后感谢<a href="http://weibo.com/436062867" target="_blank">@A-limon</a>同学提供翻译建议和审读.</p>
]]></content>
    
    
      <category term="node.js" scheme="http://se77en.cc/tags/node.js/"/>
    
      <category term="PM2" scheme="http://se77en.cc/tags/PM2/"/>
    
      <category term="node.js" scheme="http://se77en.cc/categories/node.js/"/>
    
  </entry>
  
</feed>
